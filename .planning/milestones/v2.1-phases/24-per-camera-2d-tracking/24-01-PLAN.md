---
phase: 24-per-camera-2d-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/aquapose/tracking/__init__.py
  - src/aquapose/tracking/ocsort_wrapper.py
  - src/aquapose/core/tracking/stage.py
  - src/aquapose/core/tracking/__init__.py
  - src/aquapose/engine/pipeline.py
  - src/aquapose/engine/config.py
  - tests/unit/core/tracking/test_tracking_stage.py
  - tests/unit/tracking/test_ocsort_wrapper.py
  - tests/unit/engine/test_build_stages.py
autonomous: true
requirements:
  - TRACK-01

must_haves:
  truths:
    - "Per-camera detections are independently tracked by OC-SORT, producing Tracklet2D objects with camera_id, track_id, frames, centroids, bboxes, and frame_status"
    - "Only confirmed tracklets (past n_init probationary period) appear in PipelineContext.tracks_2d output"
    - "Tracks coast (predict without observation) for up to max_coast_frames before being dropped"
    - "CarryForward preserves tracker state between batches — second batch continues tracks from first"
    - "boxmot dependency is fully isolated in aquapose.tracking.ocsort_wrapper — downstream code never sees boxmot internals"
  artifacts:
    - path: "src/aquapose/tracking/ocsort_wrapper.py"
      provides: "boxmot-isolated OC-SORT wrapper producing Tracklet2D tuples"
    - path: "src/aquapose/core/tracking/stage.py"
      provides: "TrackingStage (Stage 2) consuming detections and producing tracks_2d"
    - path: "tests/unit/tracking/test_ocsort_wrapper.py"
      provides: "Unit tests for wrapper isolation and tracklet output format"
    - path: "tests/unit/core/tracking/test_tracking_stage.py"
      provides: "Unit tests for TrackingStage contract and carry-forward"
  key_links:
    - from: "src/aquapose/core/tracking/stage.py"
      to: "src/aquapose/tracking/ocsort_wrapper.py"
      via: "TrackingStage delegates to OcSortTracker wrapper per camera"
      pattern: "OcSortTracker"
    - from: "src/aquapose/engine/pipeline.py"
      to: "src/aquapose/core/tracking/stage.py"
      via: "build_stages() instantiates TrackingStage; PosePipeline.run() dispatches with carry"
      pattern: "TrackingStage"
    - from: "src/aquapose/tracking/ocsort_wrapper.py"
      to: "src/aquapose/core/tracking/types.py"
      via: "Wrapper constructs Tracklet2D frozen dataclasses from boxmot output"
      pattern: "Tracklet2D"
---

<objective>
Implement per-camera 2D tracking using OC-SORT via the boxmot package, replacing TrackingStubStage with a real TrackingStage that produces typed Tracklet2D objects per camera. The tracking module fully isolates the boxmot dependency behind the project's own data contracts.

Purpose: Enable the association stage (Phase 25) to receive structured, per-camera tracklets with frame-level status instead of empty stubs — the foundational input for cross-camera identity matching.

Output: Working TrackingStage, boxmot wrapper, updated config, updated pipeline wiring, unit tests.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-per-camera-2d-tracking/24-CONTEXT.md
@.planning/phases/22-pipeline-scaffolding/22-01-SUMMARY.md
@.planning/phases/22-pipeline-scaffolding/22-02-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/aquapose/core/tracking/types.py:
```python
@dataclass(frozen=True)
class Tracklet2D:
    camera_id: str
    track_id: int
    frames: tuple       # tuple[int, ...]
    centroids: tuple    # tuple[tuple[float, float], ...]
    bboxes: tuple       # tuple[tuple[float, float, float, float], ...]
    frame_status: tuple  # tuple[str, ...] — "detected" or "coasted"
```

From src/aquapose/core/context.py:
```python
@dataclass(frozen=True)
class CarryForward:
    tracks_2d_state: dict = field(default_factory=dict)
    # Keys are camera_ids, values are opaque tracker state blobs

class PipelineContext:
    detections: list | None = None   # list[dict[str, list[Detection]]]
    tracks_2d: dict | None = None    # dict[str, list[Tracklet2D]]
    # ... other fields
```

From src/aquapose/engine/pipeline.py:
```python
class TrackingStubStage:
    def run(self, context: PipelineContext, carry: CarryForward | None = None) -> tuple[PipelineContext, CarryForward]:
        ...

# PosePipeline.run() dispatches via isinstance(stage, TrackingStubStage) — must be updated to TrackingStage
```

From src/aquapose/engine/config.py:
```python
@dataclass(frozen=True)
class TrackingConfig:
    max_coast_frames: int = 30  # stub — to be expanded

class PipelineConfig:
    tracking: TrackingConfig
```

From src/aquapose/segmentation/detector.py:
```python
@dataclass
class Detection:
    bbox: tuple[int, int, int, int]  # (x, y, w, h)
    mask: np.ndarray | None
    area: int
    confidence: float
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add boxmot dependency, create OcSortTracker wrapper, and write wrapper unit tests</name>
  <files>
    pyproject.toml
    src/aquapose/tracking/ocsort_wrapper.py
    src/aquapose/tracking/__init__.py
    tests/unit/tracking/__init__.py
    tests/unit/tracking/test_ocsort_wrapper.py
  </files>
  <action>
**1. Add boxmot to pyproject.toml dependencies:**
Add `"boxmot>=11.0"` to the `[project] dependencies` list in pyproject.toml. Then run `pip install boxmot` (or `hatch env prune && hatch env create`) to make it available.

**2. Create `src/aquapose/tracking/ocsort_wrapper.py`:**
This module fully isolates boxmot internals. Downstream code never imports from boxmot directly.

Create class `OcSortTracker`:
- Constructor: `__init__(self, camera_id: str, max_age: int = 30, min_hits: int = 3, iou_threshold: float = 0.3, det_thresh: float = 0.3)`.
  - `camera_id` stored as instance attribute.
  - `max_age` = max coast frames (maps to boxmot's `max_age`).
  - `min_hits` = probationary period (`n_init` — number of matched detections before confirmation).
  - Internally instantiate the boxmot OC-SORT tracker. Use `from boxmot import OCSORT` (verify exact import path — boxmot exposes `OCSORT` or `OCSORTTracker`). Pass the appropriate kwargs.
  - Maintain a `_next_track_id: int = 0` counter and a `_boxmot_id_to_local: dict[int, int]` mapping to convert boxmot's internal IDs to clean incrementing integers.
  - Maintain `_active_tracklets: dict[int, _TrackletBuilder]` keyed by local track_id, where `_TrackletBuilder` is a private mutable helper class with lists for frames, centroids, bboxes, frame_status.

- Method `update(self, frame_idx: int, detections: list) -> None`:
  - Accept a list of Detection objects (from `aquapose.segmentation.detector`).
  - Convert detections to the numpy array format boxmot expects: Nx5 array of `[x1, y1, x2, y2, confidence]` (convert from xywh to xyxy). If no detections, pass empty array.
  - Call boxmot tracker's `.update(dets, img)` — the img parameter can be a dummy empty numpy array since OC-SORT does not use appearance features (just pass `np.empty((0,0,3), dtype=np.uint8)`).
  - Read the tracker output: Nx5+ array of `[x1, y1, x2, y2, track_id, ...]`. Convert active track IDs through `_boxmot_id_to_local` (assign new local IDs for unseen boxmot IDs).
  - For each active track returned by boxmot: determine if this frame is "detected" (the track had a matched detection) or "coasted" (Kalman prediction only). The simplest approach: track IDs that appear in boxmot output but were NOT matched to any input detection are coasted. Alternatively, check if boxmot exposes a `tracker.trackers[i].time_since_update` — if 0, detected; if >0, coasted.
  - Append frame data to the corresponding `_TrackletBuilder`.
  - For `_TrackletBuilder`s that are no longer in the boxmot output and have been absent for >1 frame, mark them as finalized (they won't receive more updates).

- Method `get_tracklets(self) -> list[Tracklet2D]`:
  - Return all active+finalized tracklets that have been confirmed (i.e., appeared in at least `min_hits` frames with "detected" status). Convert each `_TrackletBuilder` to a frozen `Tracklet2D` with tuple fields.
  - This filters out tentative tracks that never graduated past probation.

- Method `get_state(self) -> dict`:
  - Return an opaque state blob (dict) capturing the boxmot tracker object and the local ID mappings, for serialization into CarryForward.

- Class method or static method `from_state(camera_id: str, state: dict) -> OcSortTracker`:
  - Reconstruct an OcSortTracker from a saved state blob.

**3. Update `src/aquapose/tracking/__init__.py`:**
Export `OcSortTracker` and add to `__all__`.

**4. Create `tests/unit/tracking/__init__.py`** (empty, for test discovery).

**5. Create `tests/unit/tracking/test_ocsort_wrapper.py`:**
Write unit tests:
- `test_empty_detections_produces_no_tracklets`: Pass 0 detections for several frames, assert `get_tracklets()` returns `[]`.
- `test_single_detection_stream_produces_one_tracklet`: Feed one detection per frame for `min_hits + 5` frames with consistent bbox. Assert one Tracklet2D with correct camera_id, incrementing frames, "detected" frame_status, matching centroids.
- `test_tracklet2d_fields_are_tuples`: Verify all sequence fields are tuples (not lists).
- `test_coasting_detection_gap`: Feed detections for `min_hits + 2` frames, then no detections for 3 frames, then detections again. Assert the tracklet has "coasted" entries in `frame_status` for the gap frames.
- `test_multiple_detections_produce_multiple_tracklets`: Feed 2+ spatially separated detections per frame. Assert `get_tracklets()` returns 2+ tracklets with distinct track_ids.
- `test_state_roundtrip`: Call `get_state()`, then `from_state()`, feed more frames, verify tracklets continue with same IDs.
- Use `@pytest.mark.skipif(not _has_boxmot(), reason="boxmot not installed")` guard if boxmot import may fail in CI. Or just let it fail naturally.

Run `hatch run test tests/unit/tracking/test_ocsort_wrapper.py -x` to verify all tests pass.
  </action>
  <verify>
    <automated>hatch run test tests/unit/tracking/test_ocsort_wrapper.py -x</automated>
  </verify>
  <done>
    - boxmot added to pyproject.toml dependencies
    - OcSortTracker wraps boxmot OC-SORT, converts output to Tracklet2D frozen dataclasses
    - All wrapper unit tests pass (empty input, single track, coasting, multi-track, state roundtrip)
    - boxmot internals fully isolated — only ocsort_wrapper.py imports from boxmot
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TrackingStage, expand TrackingConfig, rewire pipeline, write stage tests</name>
  <files>
    src/aquapose/core/tracking/stage.py
    src/aquapose/core/tracking/__init__.py
    src/aquapose/engine/pipeline.py
    src/aquapose/engine/config.py
    tests/unit/core/tracking/test_tracking_stage.py
    tests/unit/engine/test_build_stages.py
  </files>
  <action>
**1. Expand `TrackingConfig` in `src/aquapose/engine/config.py`:**
Replace the stub `TrackingConfig` with full OC-SORT configuration. Keep `_filter_fields()` in `load_config` to handle stale keys. New fields:
```python
@dataclass(frozen=True)
class TrackingConfig:
    tracker_kind: str = "ocsort"       # Configurable model (ocsort, bytetrack, sort — per CONTEXT.md)
    max_coast_frames: int = 30         # max_age for boxmot
    n_init: int = 3                    # Probationary period (min_hits)
    iou_threshold: float = 0.3         # IoU threshold for matching
    det_thresh: float = 0.3            # Detection confidence threshold
```

**2. Create `src/aquapose/core/tracking/stage.py` — TrackingStage:**

```python
class TrackingStage:
    """Stage 2: Per-camera 2D tracking.

    Consumes context.detections (Stage 1 output) and produces
    context.tracks_2d (dict[str, list[Tracklet2D]]).

    Each camera's detections are independently tracked by an OcSortTracker.
    CarryForward preserves tracker state between batches.
    """
```

Constructor: `__init__(self, config: TrackingConfig)` — stores config, does NOT create trackers yet (they are created per-camera during run).

Method `run(self, context: PipelineContext, carry: CarryForward | None = None) -> tuple[PipelineContext, CarryForward]`:
- Read `context.detections` (list of per-frame dicts: `list[dict[str, list[Detection]]]`) and `context.camera_ids`.
- For each camera_id: restore `OcSortTracker` from `carry.tracks_2d_state[camera_id]` if it exists, else create fresh `OcSortTracker(camera_id=camera_id, max_age=config.max_coast_frames, min_hits=config.n_init, iou_threshold=config.iou_threshold, det_thresh=config.det_thresh)`.
- Iterate frames (0 to len(detections)-1): for each camera, call `tracker.update(frame_idx, detections_for_this_camera_this_frame)`.
- After all frames: call `tracker.get_tracklets()` for each camera. Store in `context.tracks_2d = {cam_id: tracklets, ...}`.
- Build new `CarryForward(tracks_2d_state={cam_id: tracker.get_state(), ...})`.
- Return `(context, carry)`.

**3. Update `src/aquapose/core/tracking/__init__.py`:**
Add `TrackingStage` to imports and `__all__`.

**4. Rewire `src/aquapose/engine/pipeline.py`:**
- Remove `TrackingStubStage` class entirely.
- In `build_stages()`: import `TrackingStage` from `aquapose.core.tracking`. Replace `TrackingStubStage()` with `TrackingStage(config=config.tracking)`.
- In `PosePipeline.run()`: change `isinstance(stage, TrackingStubStage)` to `isinstance(stage, TrackingStage)`. Import `TrackingStage` at the top of the file (or use lazy import within run — follow existing pattern; TrackingStubStage was defined locally so just change the reference).

  **IMPORTANT:** `TrackingStage` is in core/ — import it from `aquapose.core.tracking` in pipeline.py. The isinstance check in `PosePipeline.run()` requires the actual class at runtime, not just a Protocol. This is the same pattern the stub used. If import boundary rules (ENG-07) prohibit engine importing from core at module level, use a deferred import inside `run()` — but note that `build_stages()` already does deferred imports from core, so follow that pattern.

**5. Create `tests/unit/core/tracking/test_tracking_stage.py`:**
Unit tests for TrackingStage:
- `test_empty_detections_produces_empty_tracks_2d`: Create a PipelineContext with detections=[] (or list of empty dicts), call TrackingStage.run(). Assert tracks_2d is an empty dict.
- `test_single_camera_single_fish`: Build a synthetic detection list (1 camera, 1 detection per frame for 10 frames with consistent bbox). Run TrackingStage. Assert tracks_2d has 1 camera key with 1+ Tracklet2D entries.
- `test_carry_forward_preserves_state`: Run TrackingStage on batch 1, get carry. Run on batch 2 with same carry. Assert track IDs are consistent across batches (same fish gets same track_id).
- `test_multiple_cameras_independent`: Feed 2 cameras with different detection patterns. Assert tracks_2d has 2 keys with independent tracklets.
- `test_tracklet_fields_match_spec`: Verify Tracklet2D fields are the correct types (tuples, correct camera_id, etc.).

Use mock detections — create Detection objects with synthetic bboxes (no mask needed, just bbox and confidence).

**6. Update `tests/unit/engine/test_build_stages.py`:**
Replace `TrackingStubStage` references with `TrackingStage`. The test that checks "5 stages returned" should now verify the second stage is a `TrackingStage` instance (not `TrackingStubStage`). Update any imports.

Run full test suite: `hatch run test -x` to verify no regressions.
  </action>
  <verify>
    <automated>hatch run test -x</automated>
  </verify>
  <done>
    - TrackingStage in core/tracking/stage.py replaces TrackingStubStage
    - TrackingConfig expanded with tracker_kind, n_init, iou_threshold, det_thresh
    - build_stages() instantiates TrackingStage with config.tracking
    - PosePipeline.run() dispatches TrackingStage with carry argument via isinstance
    - CarryForward preserves per-camera tracker state between batches
    - All unit tests pass (tracking stage contract, carry-forward, pipeline wiring)
    - Full test suite passes with no regressions
  </done>
</task>

</tasks>

<verification>
1. `hatch run test -x` — full unit test suite passes (no regressions)
2. `hatch run lint` — no ruff violations
3. `hatch run typecheck` — no type errors in modified files
4. Verify boxmot is isolated: `grep -r "from boxmot\|import boxmot" src/aquapose/ | grep -v ocsort_wrapper` returns no matches
5. Verify TrackingStubStage is gone: `grep -r "TrackingStubStage" src/aquapose/` returns no matches
</verification>

<success_criteria>
- Detections from each camera are passed through an independent OC-SORT tracker that maintains track identity across frames
- Output tracklets contain camera_id, track_id, frames, centroids, bboxes, and frame_status as typed Tracklet2D dataclass
- The DetectionStage emits detections and TrackingStage consumes them per-camera, storing tracklets in PipelineContext.tracks_2d
- Tracks coast for up to max_coast_frames before being dropped
- CarryForward carries per-camera tracker state between batches
- boxmot dependency is fully isolated in aquapose.tracking.ocsort_wrapper
- TrackingStubStage is removed from the codebase
</success_criteria>

<output>
After completion, create `.planning/phases/24-per-camera-2d-tracking/24-01-SUMMARY.md`
</output>
