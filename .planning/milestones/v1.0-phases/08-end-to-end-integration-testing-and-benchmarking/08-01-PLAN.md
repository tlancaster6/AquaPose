---
phase: 08-end-to-end-integration-testing-and-benchmarking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aquapose/pipeline/__init__.py
  - src/aquapose/pipeline/orchestrator.py
  - src/aquapose/pipeline/stages.py
  - src/aquapose/io/midline_writer.py
  - src/aquapose/io/__init__.py
  - tests/unit/io/test_midline_writer.py
  - tests/unit/pipeline/test_stages.py
autonomous: true
requirements:
  - OUT-01

must_haves:
  truths:
    - "reconstruct() chains all 5 stages (detect, segment, track, extract midlines, triangulate) and returns a ReconstructResult with midlines_3d, output_dir, and stage_timing"
    - "Midline3DWriter writes per-frame 3D midline data to HDF5 with control_points, half_widths, n_cameras, residuals, and is_low_confidence fields"
    - "HDF5 midline data round-trips correctly — written data can be read back and matches the original Midline3D fields"
    - "Stateful objects (FishTracker, MidlineExtractor) are instantiated once and persist across all frames, not re-created per chunk"
  artifacts:
    - path: "src/aquapose/pipeline/orchestrator.py"
      provides: "reconstruct() entry point, ReconstructResult dataclass"
      exports: ["reconstruct", "ReconstructResult"]
    - path: "src/aquapose/pipeline/stages.py"
      provides: "Per-stage batch functions: run_detection, run_segmentation, run_tracking, run_midline_extraction, run_triangulation"
      exports: ["run_detection", "run_segmentation", "run_tracking", "run_midline_extraction", "run_triangulation"]
    - path: "src/aquapose/io/midline_writer.py"
      provides: "HDF5 chunked-append writer for Midline3D data"
      exports: ["Midline3DWriter", "read_midline3d_results"]
    - path: "tests/unit/io/test_midline_writer.py"
      provides: "Round-trip and edge case tests for Midline3DWriter"
    - path: "tests/unit/pipeline/test_stages.py"
      provides: "Unit tests for stage functions with mocked dependencies"
  key_links:
    - from: "src/aquapose/pipeline/orchestrator.py"
      to: "src/aquapose/pipeline/stages.py"
      via: "imports stage functions and chains them sequentially"
      pattern: "from aquapose\\.pipeline\\.stages import"
    - from: "src/aquapose/pipeline/orchestrator.py"
      to: "src/aquapose/io/midline_writer.py"
      via: "writes final Midline3D results to HDF5"
      pattern: "Midline3DWriter"
    - from: "src/aquapose/pipeline/stages.py"
      to: "src/aquapose/segmentation/detector.py"
      via: "uses MOG2Detector/YOLODetector for detection stage"
      pattern: "make_detector|MOG2Detector"
    - from: "src/aquapose/pipeline/stages.py"
      to: "src/aquapose/tracking/tracker.py"
      via: "uses FishTracker for cross-view identity"
      pattern: "FishTracker"
    - from: "src/aquapose/pipeline/stages.py"
      to: "src/aquapose/reconstruction/midline.py"
      via: "uses MidlineExtractor for 2D midline extraction"
      pattern: "MidlineExtractor"
    - from: "src/aquapose/pipeline/stages.py"
      to: "src/aquapose/reconstruction/triangulation.py"
      via: "uses triangulate_midlines for 3D reconstruction"
      pattern: "triangulate_midlines"
---

<objective>
Build the pipeline orchestrator (`reconstruct()` API), per-stage batch functions, and HDF5 3D midline writer.

Purpose: Provide the callable entry point that chains all 5 reconstruction stages together, and the HDF5 output infrastructure for persisting 3D midline results (OUT-01).

Output: `src/aquapose/pipeline/` package with orchestrator and stages, `src/aquapose/io/midline_writer.py` with chunked HDF5 writer, unit tests for both.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-end-to-end-integration-testing-and-benchmarking/08-CONTEXT.md
@.planning/phases/08-end-to-end-integration-testing-and-benchmarking/08-RESEARCH.md
@src/aquapose/tracking/writer.py
@src/aquapose/tracking/tracker.py
@src/aquapose/reconstruction/triangulation.py
@src/aquapose/reconstruction/midline.py
@src/aquapose/segmentation/detector.py
@src/aquapose/segmentation/model.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pipeline orchestrator, stage functions, and HDF5 midline writer</name>
  <files>
    src/aquapose/pipeline/__init__.py
    src/aquapose/pipeline/orchestrator.py
    src/aquapose/pipeline/stages.py
    src/aquapose/io/midline_writer.py
    src/aquapose/io/__init__.py
  </files>
  <action>
Create `src/aquapose/pipeline/` package with three files:

**`stages.py`** — Five independently callable stage functions:

1. `run_detection(video_paths: dict[str, Path], stop_frame: int | None = None, detector_kind: str = "mog2", **detector_kwargs) -> list[dict[str, list[Detection]]]`
   - Creates one detector per camera via `make_detector(detector_kind, **detector_kwargs)`
   - Opens each video with `cv2.VideoCapture`, reads frames in lockstep across cameras
   - Returns list indexed by frame_idx, each entry is `{camera_id: [Detection, ...]}`
   - Releases all captures in finally block

2. `run_segmentation(detections_per_frame: list[dict[str, list[Detection]]], video_paths: dict[str, Path], segmentor: UNetSegmentor, stop_frame: int | None = None) -> list[dict[str, list[tuple[np.ndarray, CropRegion]]]]`
   - Re-reads video frames (detection stage does not store raw frames to save memory)
   - For each frame+camera, crops detections and runs segmentor.segment()
   - Returns list indexed by frame_idx: `{camera_id: [(mask, crop_region), ...]}`

3. `run_tracking(detections_per_frame: list[dict[str, list[Detection]]], models: dict[str, RefractiveProjectionModel], tracker: FishTracker) -> list[list[FishTrack]]`
   - Accepts an externally-created `FishTracker` instance (MUST NOT create a new one internally)
   - Calls `tracker.update(frame_dets, models, frame_index)` for each frame
   - Returns list indexed by frame_idx of confirmed tracks

4. `run_midline_extraction(tracks_per_frame: list[list[FishTrack]], masks_per_frame: list[dict[str, list[tuple[np.ndarray, CropRegion]]]], detections_per_frame: list[dict[str, list[Detection]]], models: dict[str, RefractiveProjectionModel], extractor: MidlineExtractor) -> list[MidlineSet]`
   - Accepts an externally-created `MidlineExtractor` instance (MUST NOT create a new one internally)
   - For each frame, assembles masks_per_camera and crop_regions_per_camera from the tracks' camera assignments, calls `extractor.extract_midlines()`
   - Returns list indexed by frame_idx of `MidlineSet` (= `dict[int, dict[str, Midline2D]]`)

5. `run_triangulation(midline_sets: list[MidlineSet], models: dict[str, RefractiveProjectionModel]) -> list[dict[int, Midline3D]]`
   - For each frame, calls `triangulate_midlines(midline_set, models, frame_index=idx)`
   - Returns list indexed by frame_idx of `{fish_id: Midline3D}`

All stage functions log timing via `logging.getLogger(__name__)` at INFO level.

**`orchestrator.py`** — Main entry point:

```python
@dataclass
class ReconstructResult:
    output_dir: Path
    midlines_3d: list[dict[int, Midline3D]]
    stage_timing: dict[str, float]
```

`reconstruct(video_dir: Path, calibration_path: Path, output_dir: Path, *, stop_frame: int | None = None, mode: str = "production", detector_kind: str = "mog2", unet_weights: Path | None = None, max_fish: int = 9, **detector_kwargs) -> ReconstructResult`

- Discovers camera video files from `video_dir` (glob `*.avi` or `*.mp4`), excludes `e3v8250` by checking if camera_id matches
- Loads calibration via `CalibrationData.from_json(calibration_path)` and builds `RefractiveProjectionModel` per camera
- Creates stateful objects once: `FishTracker(models, population=max_fish)`, `MidlineExtractor()`, `UNetSegmentor(unet_weights)` if weights provided
- Chains the 5 stage functions with `time.perf_counter()` timing around each
- After triangulation, writes results to HDF5 via `Midline3DWriter` in `output_dir / "midlines_3d.h5"`
- If `mode == "diagnostic"`: sets `cache_intermediates=True` (saves detection/mask data to `output_dir` as `.npz` files per-stage)
- Returns `ReconstructResult` with all results and timing

**`__init__.py`** — Export `reconstruct`, `ReconstructResult`.

**`src/aquapose/io/midline_writer.py`** — HDF5 chunked-append writer modeled exactly on `TrackingWriter`:

`class Midline3DWriter`:
- `__init__(self, output_path: Path, max_fish: int = 9, chunk_frames: int = 1000)`
- Creates `/midlines/` group with datasets:
  - `frame_index` (N,) int64
  - `fish_id` (N, max_fish) int32, fillvalue=-1
  - `control_points` (N, max_fish, 7, 3) float32, fillvalue=NaN
  - `arc_length` (N, max_fish) float32, fillvalue=NaN
  - `half_widths` (N, max_fish, 15) float32, fillvalue=NaN
  - `n_cameras` (N, max_fish) int32, fillvalue=0
  - `mean_residual` (N, max_fish) float32, fillvalue=-1.0
  - `max_residual` (N, max_fish) float32, fillvalue=-1.0
  - `is_low_confidence` (N, max_fish) dtype="bool", fillvalue=False
- Stores SPLINE_KNOTS and SPLINE_K as group attributes (constant across frames)
- `write_frame(frame_index: int, midlines: dict[int, Midline3D])`: fills buffer row, flushes when chunk_frames reached
- `close()`: flushes remaining buffer, closes file
- Context manager protocol (`__enter__`/`__exit__`)
- Uses `cast(h5py.Dataset, ...)` for basedpyright narrowing (same pattern as TrackingWriter)

`def read_midline3d_results(path: str | Path) -> dict[str, Any]`: reads all datasets back into numpy arrays.

Update **`src/aquapose/io/__init__.py`** to export `Midline3DWriter` and `read_midline3d_results`.
  </action>
  <verify>
    - `hatch run check` passes (lint + typecheck)
    - `python -c "from aquapose.pipeline import reconstruct, ReconstructResult"` succeeds
    - `python -c "from aquapose.io import Midline3DWriter, read_midline3d_results"` succeeds
  </verify>
  <done>
    - Pipeline orchestrator chains 5 stages with timing, returns ReconstructResult
    - Stage functions are independently callable with correct interfaces
    - HDF5 midline writer follows TrackingWriter chunked-append pattern exactly
    - All exports available from package __init__.py
    - Lint and typecheck pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for midline writer and stage functions</name>
  <files>
    tests/unit/io/test_midline_writer.py
    tests/unit/pipeline/__init__.py
    tests/unit/pipeline/test_stages.py
  </files>
  <action>
**`tests/unit/io/test_midline_writer.py`** — Tests for Midline3DWriter (modeled on test_writer.py from Phase 5):

1. `test_write_read_round_trip`: Write 3 frames with 2 fish each, read back, verify control_points, half_widths, n_cameras, residuals, is_low_confidence match originals
2. `test_chunk_flush`: Write chunk_frames+1 rows (chunk_frames=2), verify 2 flushes occurred by checking dataset size grows correctly
3. `test_context_manager`: Verify `with Midline3DWriter(...) as w:` works and file is closed after exit
4. `test_fillvalues_for_missing_fish`: Write a frame with only 1 fish (out of max_fish=3), verify unfilled slots have fish_id=-1, control_points=NaN, n_cameras=0
5. `test_knots_and_degree_as_attrs`: Verify SPLINE_KNOTS and SPLINE_K are stored as group attributes, not datasets
6. `test_empty_frame`: Write a frame with empty dict, verify fill-values everywhere

Create `Midline3D` test fixtures using `triangulation.SPLINE_KNOTS`, `SPLINE_K`, `N_SAMPLE_POINTS`.

**`tests/unit/pipeline/test_stages.py`** — Tests for stage functions with mocked dependencies:

1. `test_run_triangulation`: Create synthetic MidlineSets with 2 fish, 3 cameras, mock `triangulate_midlines` to return dummy Midline3D, verify output structure
2. `test_run_tracking_preserves_tracker_state`: Create a FishTracker with mock models, call run_tracking with 5 frames, verify tracker.frame_index advances (stateful object not re-created)

Use `monkeypatch` / `unittest.mock.patch` to mock heavy dependencies (cv2.VideoCapture, detector, segmentor, triangulate_midlines). Tests must be fast and GPU-free.

Create `tests/unit/pipeline/__init__.py` (empty).
  </action>
  <verify>
    - `hatch run test tests/unit/io/test_midline_writer.py` — all tests pass
    - `hatch run test tests/unit/pipeline/test_stages.py` — all tests pass
    - `hatch run check` passes
  </verify>
  <done>
    - 6+ midline writer tests pass covering round-trip, chunking, context manager, fill-values, attributes, empty frames
    - 2+ stage function tests pass with mocked dependencies
    - All tests are fast (no GPU, no video I/O)
  </done>
</task>

</tasks>

<verification>
- `hatch run check` passes (lint + typecheck across all new files)
- `hatch run test tests/unit/io/test_midline_writer.py tests/unit/pipeline/test_stages.py` — all pass
- `python -c "from aquapose.pipeline import reconstruct, ReconstructResult; from aquapose.io import Midline3DWriter, read_midline3d_results"` succeeds
</verification>

<success_criteria>
- reconstruct() callable API exists with mode="diagnostic"|"production", stop_frame, configurable output_dir
- Each of the 5 stages is independently callable
- HDF5 midline output includes all OUT-01 fields (fish_id, control_points, half_widths, n_cameras, residuals, is_low_confidence, knots, degree)
- Unit tests demonstrate correct round-trip serialization
- Stateful objects (FishTracker, MidlineExtractor) persist across frames
</success_criteria>

<output>
After completion, create `.planning/phases/08-end-to-end-integration-testing-and-benchmarking/08-01-SUMMARY.md`
</output>
