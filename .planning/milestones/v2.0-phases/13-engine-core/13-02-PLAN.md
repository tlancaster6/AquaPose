---
phase: 13-engine-core
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/aquapose/engine/config.py
  - tests/unit/engine/test_config.py
autonomous: true
requirements:
  - ENG-05

must_haves:
  truths:
    - "A frozen config object can be constructed from defaults, overridden by YAML, then overridden by CLI kwargs"
    - "Post-freeze mutation raises an error"
    - "Config is hierarchical — each stage gets its own config subtree"
  artifacts:
    - path: "src/aquapose/engine/config.py"
      provides: "Frozen dataclass config hierarchy with YAML + CLI override loading"
      exports: ["PipelineConfig", "load_config"]
      min_lines: 60
    - path: "tests/unit/engine/test_config.py"
      provides: "Tests for config defaults, YAML override, CLI override, freeze behavior"
      min_lines: 50
  key_links:
    - from: "src/aquapose/engine/config.py"
      to: "dataclasses"
      via: "Frozen dataclasses for config"
      pattern: "frozen=True"
    - from: "src/aquapose/engine/config.py"
      to: "yaml"
      via: "YAML loading for config overrides"
      pattern: "yaml.safe_load"
---

<objective>
Implement the frozen dataclass config hierarchy with defaults, YAML file override, and CLI kwarg override support. Config freezes after construction and raises on mutation.

Purpose: Every pipeline run needs a deterministic, reproducible config. The loading precedence (defaults -> YAML -> CLI -> freeze) ensures flexibility while the frozen guarantee prevents accidental mutation during execution.
Output: `src/aquapose/engine/config.py` with config dataclasses and `load_config()` function, plus unit tests.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-engine-core/13-CONTEXT.md

<interfaces>
<!-- No prior engine config exists. This plan creates the config system. -->

From CONTEXT.md decisions:
- Frozen dataclasses, hierarchical by stage
- Loading precedence: defaults -> YAML -> CLI overrides -> freeze
- Raises on post-freeze mutation
- Execution modes (production, diagnostic, synthetic, benchmark) are named config presets merged before freezing
- Full serialized config logged as first artifact of every run — the reproducibility contract
- Run identity: timestamp-based (run_20260225_143022)
- Artifact path: ~/aquapose/runs/{run_id}/ as default, overridable via config
- NOT pydantic — frozen dataclasses only
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement frozen config dataclass hierarchy with YAML and CLI override loading</name>
  <files>src/aquapose/engine/config.py</files>
  <action>
Create `src/aquapose/engine/config.py`:

**Config dataclass hierarchy (all `frozen=True`):**

1. `DetectionConfig` — stage-specific config:
   - `detector_kind: str = "yolo"` (detector type)
   - `stop_frame: int | None = None`
   - Additional kwargs stored as `extra: dict[str, object]` using `field(default_factory=dict)` — note: for frozen dataclasses, use `object.__setattr__` trick or build via `__init__` to set mutable defaults

2. `SegmentationConfig`:
   - `confidence_threshold: float = 0.5`
   - `weights_path: str | None = None`

3. `TrackingConfig`:
   - `max_fish: int = 9`

4. `TriangulationConfig`:
   - (empty for now, placeholder for future params)

5. `PipelineConfig` — top-level frozen dataclass:
   - `run_id: str` — timestamp-based identifier (e.g., "run_20260225_143022")
   - `output_dir: str` — artifact output path, default `"~/aquapose/runs/{run_id}"`
   - `video_dir: str = ""`
   - `calibration_path: str = ""`
   - `mode: str = "production"` — execution mode (production, diagnostic, synthetic, benchmark)
   - `detection: DetectionConfig`
   - `segmentation: SegmentationConfig`
   - `tracking: TrackingConfig`
   - `triangulation: TriangulationConfig`

Since `frozen=True` dataclasses don't allow post-init assignment, use `__post_init__` with `object.__setattr__` only during construction for computed defaults (e.g., output_dir with run_id interpolation). Alternatively, compute everything in the factory function.

**Factory function `load_config()`:**

```python
def load_config(
    yaml_path: str | Path | None = None,
    *,
    cli_overrides: dict[str, object] | None = None,
    run_id: str | None = None,
) -> PipelineConfig:
```

Steps:
1. Start with defaults (dataclass field defaults)
2. If `yaml_path` provided, load YAML via `yaml.safe_load()` and merge — YAML keys map to nested dataclass fields using dot notation or nested dicts (e.g., `detection.detector_kind: "mog2"`)
3. If `cli_overrides` provided, merge on top (highest precedence)
4. Generate `run_id` if not provided: `f"run_{datetime.now():%Y%m%d_%H%M%S}"`
5. Construct and return frozen `PipelineConfig`

**Serialization helper:**

```python
def serialize_config(config: PipelineConfig) -> str:
```
Returns YAML string representation using `dataclasses.asdict()` + `yaml.dump()`. This is used by the orchestrator (plan 13-04) to write the config artifact.

**Import boundary:** Only stdlib + PyYAML. No aquapose computation module imports.

Update `src/aquapose/engine/__init__.py` to export `PipelineConfig`, `load_config`, `serialize_config` and add them to `__all__`.
  </action>
  <verify>
    <automated>cd C:/Users/tucke/PycharmProjects/AquaPose && python -c "from aquapose.engine.config import PipelineConfig, load_config, serialize_config; print('config imports OK')"</automated>
  </verify>
  <done>Config module exists with frozen dataclass hierarchy, load_config factory, and serialize_config helper.</done>
</task>

<task type="auto">
  <name>Task 2: Write tests for config defaults, YAML override, CLI override, freeze, and serialization</name>
  <files>tests/unit/engine/test_config.py</files>
  <action>
Create `tests/unit/engine/test_config.py`:

**Tests to write:**

1. **`test_load_config_defaults`** — Call `load_config()` with no args. Assert all stage configs have expected defaults (e.g., `config.detection.detector_kind == "yolo"`, `config.tracking.max_fish == 9`). Assert `config.mode == "production"`.

2. **`test_load_config_yaml_override`** — Write a temp YAML file with `detection: {detector_kind: "mog2"}` and `tracking: {max_fish: 5}`. Call `load_config(yaml_path=tmp)`. Assert overrides applied, non-overridden fields retain defaults.

3. **`test_load_config_cli_overrides`** — Call `load_config(cli_overrides={"detection.detector_kind": "mog2"})` or equivalent dict structure. Assert CLI override takes effect.

4. **`test_cli_overrides_trump_yaml`** — Provide both YAML (detector_kind="mog2") and CLI (detector_kind="yolo"). Assert CLI wins.

5. **`test_frozen_config_raises_on_mutation`** — Load a config, attempt `config.mode = "diagnostic"`. Assert `FrozenInstanceError` (or `dataclasses.FrozenInstanceError`) is raised. This is the critical freeze guarantee.

6. **`test_run_id_auto_generated`** — Call `load_config()` without explicit run_id. Assert `config.run_id` starts with `"run_"` and has timestamp format.

7. **`test_run_id_explicit`** — Call `load_config(run_id="run_test123")`. Assert `config.run_id == "run_test123"`.

8. **`test_serialize_config_roundtrip`** — Load config, serialize to YAML string, parse the YAML string back, verify key fields match.

Run with: `hatch run test tests/unit/engine/test_config.py -x`
  </action>
  <verify>
    <automated>cd C:/Users/tucke/PycharmProjects/AquaPose && hatch run test tests/unit/engine/test_config.py -x</automated>
  </verify>
  <done>All 8 tests pass. Config loads from defaults, YAML overrides work, CLI overrides trump YAML, frozen mutation raises, serialization roundtrips.</done>
</task>

</tasks>

<verification>
1. `from aquapose.engine.config import PipelineConfig, load_config, serialize_config` succeeds
2. `load_config()` returns a PipelineConfig with sensible defaults
3. YAML and CLI overrides apply in correct precedence order
4. Mutating a frozen config raises an error
5. `hatch run test tests/unit/engine/test_config.py -x` — all tests pass
</verification>

<success_criteria>
- PipelineConfig and stage-specific configs are frozen dataclasses
- load_config() supports defaults -> YAML -> CLI override precedence
- Post-freeze mutation raises FrozenInstanceError
- serialize_config() produces valid YAML from config
- 8 unit tests pass covering all config behaviors
</success_criteria>

<output>
After completion, create `.planning/phases/13-engine-core/13-02-SUMMARY.md`
</output>
