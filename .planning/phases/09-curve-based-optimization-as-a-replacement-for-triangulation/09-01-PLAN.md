---
phase: 09-curve-based-optimization-as-a-replacement-for-triangulation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aquapose/reconstruction/curve_optimizer.py
  - tests/unit/test_curve_optimizer.py
autonomous: true
requirements: [RECON-03, RECON-04, RECON-05]
must_haves:
  truths:
    - "CurveOptimizer produces Midline3D output with correct control_points, knots, arc_length, and residuals"
    - "Coarse-to-fine optimization converges on synthetic multi-camera data with known ground truth"
    - "Warm-start from previous frame reduces iteration count compared to cold start"
    - "Per-fish adaptive early stopping freezes converged fish while continuing optimization on others"
    - "All regularization weights are exposed via CurveOptimizerConfig dataclass"
  artifacts:
    - path: "src/aquapose/reconstruction/curve_optimizer.py"
      provides: "CurveOptimizerConfig, CurveOptimizer, optimize_midlines"
      contains: "class CurveOptimizer"
    - path: "tests/unit/test_curve_optimizer.py"
      provides: "Unit tests for basis matrix, chamfer, loss, optimizer"
      contains: "test_"
  key_links:
    - from: "src/aquapose/reconstruction/curve_optimizer.py"
      to: "src/aquapose/calibration/projection.py"
      via: "RefractiveProjectionModel.project() for differentiable reprojection"
      pattern: "model\\.project"
    - from: "src/aquapose/reconstruction/curve_optimizer.py"
      to: "src/aquapose/reconstruction/triangulation.py"
      via: "Outputs Midline3D dataclass with same contract"
      pattern: "Midline3D"
---

<objective>
Implement the core curve-based 3D midline optimizer module that replaces point-correspondence triangulation with correspondence-free B-spline optimization.

Purpose: The current triangulation pipeline has five interacting subsystems (orientation alignment, epipolar snapping, point-wise triangulation, spline fitting, NaN filtering) with confirmed bugs. The curve optimizer eliminates all of these by directly optimizing 3D B-spline control points against 2D skeleton observations via chamfer distance and refractive reprojection.

Output: `src/aquapose/reconstruction/curve_optimizer.py` containing CurveOptimizerConfig, CurveOptimizer class, and all supporting functions. Unit tests in `tests/unit/test_curve_optimizer.py`.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-curve-based-optimization-as-a-replacement-for-triangulation/09-CONTEXT.md
@.planning/phases/09-curve-based-optimization-as-a-replacement-for-triangulation/09-RESEARCH.md
@.planning/inbox/curve_optimization_proposal.md
@src/aquapose/reconstruction/triangulation.py
@src/aquapose/calibration/projection.py
@src/aquapose/reconstruction/midline.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement curve_optimizer.py with CurveOptimizerConfig and CurveOptimizer</name>
  <files>src/aquapose/reconstruction/curve_optimizer.py</files>
  <action>
Create `src/aquapose/reconstruction/curve_optimizer.py` with the following components:

**CurveOptimizerConfig dataclass** with all exposed hyperparameters per CONTEXT.md:
- `nominal_length_m: float = 0.085` (midpoint of 70-100mm range per user decision)
- `length_tolerance: float = 0.30` (±30%)
- `lambda_length`, `lambda_curvature`, `lambda_smoothness` weights
- `max_bend_angle_deg: float` (Claude's discretion — pick a reasonable value from fish biomechanics, e.g., 30°)
- `n_coarse_ctrl: int = 4`, `n_fine_ctrl: int = 7`
- `n_eval_points: int = 20` for spline evaluation during loss
- `lbfgs_lr`, `lbfgs_max_iter_coarse`, `lbfgs_max_iter_fine`
- `convergence_delta`, `convergence_patience` for adaptive early stopping
- `warm_start_loss_ratio: float = 2.0` for fallback to cold start

**B-spline basis matrix utilities:**
- `_build_basis_matrix(n_eval, n_ctrl) -> torch.Tensor` using scipy.interpolate.BSpline with clamped uniform knots
- Module-level `_BASIS_CACHE` dict keyed by `(n_eval, n_ctrl)`
- `get_basis(n_eval, n_ctrl, device) -> torch.Tensor`
- Use the SAME knot formula as existing `SPLINE_KNOTS` for K=7 to ensure `Midline3D.knots` consistency

**Chamfer distance:**
- `_chamfer_distance_2d(proj, obs) -> torch.Tensor` using `torch.cdist` for symmetric chamfer (mean both directions)
- Handle empty obs or proj tensors gracefully (return 0)

**Loss functions:**
- `_data_loss(ctrl_pts, basis, midlines_per_fish, models, config) -> torch.Tensor` — for each fish, evaluate spline via basis matrix multiply, reproject through each camera's `model.project()`, compute chamfer distance to observed skeleton points, aggregate per-camera with `F.huber_loss` (delta ~15-20px per Pitfall 7). Filter NaN/invalid projections per Anti-Pattern note.
- `_length_penalty(ctrl_pts, basis, config) -> torch.Tensor` — evaluate spline, compute arc length via segment sums, penalize deviation from `nominal_length_m ± length_tolerance`
- `_curvature_penalty(ctrl_pts, config) -> torch.Tensor` — for each consecutive triplet of control points, compute bend angle, penalize angles exceeding `max_bend_angle_deg`
- `_smoothness_penalty(ctrl_pts) -> torch.Tensor` — second-difference penalty on control points

**Initialization:**
- `_cold_start(centroid, orientation, K, nominal_length, device) -> torch.Tensor` — straight line spline centered at centroid, oriented along skeleton PCA direction, with K control points spaced evenly over nominal_length
- `_init_ctrl_pts(fish_ids, centroids, warm_starts, K, config, ref_orientations, device) -> torch.Tensor` — for each fish, use warm-start if available (detach().clone()), else cold-start. Returns `(N_fish, K, 3)` tensor.
- Coarse-to-fine upsampling: evaluate coarse spline at fine parameter positions via basis matrix multiply to initialize fine control points

**CurveOptimizer class:**
- `__init__(self, config=None)` — stores config, `_warm_starts: dict[int, torch.Tensor]` for previous frame's control points
- `optimize_midlines(self, midline_set, models, frame_index=0, fish_centroids=None) -> dict[int, Midline3D]`:
  1. Move all models to GPU via `model.to(device)` (Pitfall 2)
  2. Extract fish_ids, gather 2D skeleton points per fish per camera as torch tensors on GPU
  3. Get reference camera orientation (longest arc) per fish for cold-start PCA
  4. Initialize coarse control points `(N_fish, 4, 3)` via `_init_ctrl_pts`
  5. Run coarse L-BFGS stage with `line_search_fn="strong_wolfe"`, `history_size=10`
     - Closure: `zero_grad()`, compute total loss, `backward()`, zero grad for inactive fish, return loss
     - Track per-fish loss deltas for adaptive early stopping (Pitfall 1)
  6. Upsample to fine `(N_fish, 7, 3)` via basis matrix
  7. If warm-start available and warm loss > `warm_start_loss_ratio * prev_loss`, fall back to cold start for that fish
  8. Run fine L-BFGS stage with convergence masking
  9. Convert output to `dict[int, Midline3D]`:
     - `control_points = ctrl.detach().cpu().numpy().astype(np.float32)` (Pitfall 6)
     - `knots = SPLINE_KNOTS.astype(np.float32)` (reuse from triangulation.py for consistency)
     - Compute arc_length, residuals, n_cameras, is_low_confidence
     - Half-widths: use `_pixel_half_width_to_metres` from triangulation.py (keep unchanged per proposal)
  10. Store fine control points in `_warm_starts` for next frame

**Key constraints from CONTEXT.md (locked decisions):**
- Fish body length is 70-100mm (NOT 45mm from proposal draft)
- All regularization weights exposed via CurveOptimizerConfig
- Global species prior only — no per-identity length refinement
- CUDA GPU optimization with batched `(N_fish, K, 3)` tensors
- Adaptive early stopping with per-fish convergence masking
- `detach().clone().requires_grad_(True)` for warm-start copy (Pitfall 6)

**Key anti-patterns to avoid (from RESEARCH.md):**
- No per-fish Python loops inside L-BFGS closure — batch everything
- Call `model.to(device)` before optimization
- Use `loss.backward()` inside closure, not `torch.autograd.grad`
- Filter NaN from `project()` before chamfer computation
- Set Huber delta in pixel units (~15-20px)
  </action>
  <verify>
`hatch run python -c "from aquapose.reconstruction.curve_optimizer import CurveOptimizer, CurveOptimizerConfig; print('Import OK')"` succeeds.
`hatch run typecheck` passes for `src/aquapose/reconstruction/curve_optimizer.py`.
  </verify>
  <done>
CurveOptimizer class exists with optimize_midlines() that accepts MidlineSet + models and returns dict[int, Midline3D]. CurveOptimizerConfig exposes all regularization weights. B-spline basis, chamfer distance, coarse-to-fine, warm-start, and adaptive early stopping are all implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for curve optimizer components</name>
  <files>tests/unit/test_curve_optimizer.py</files>
  <action>
Create `tests/unit/test_curve_optimizer.py` with the following test cases:

**B-spline basis matrix tests:**
- `test_basis_matrix_shape`: verify `_build_basis_matrix(20, 7)` returns shape `(20, 7)`
- `test_basis_matrix_partition_of_unity`: verify rows sum to ~1.0 (B-spline partition of unity property)
- `test_basis_matrix_endpoints`: verify first row has weight 1.0 on first control point, last row on last control point (clamped knot property)
- `test_basis_cache`: verify `get_basis` returns same object for same args (cache hit)

**Chamfer distance tests:**
- `test_chamfer_identical_points`: chamfer between identical point sets is 0
- `test_chamfer_known_distance`: chamfer between two known point sets matches expected value
- `test_chamfer_empty_input`: graceful handling of empty tensors

**Loss function tests:**
- `test_length_penalty_nominal`: penalty is 0 when arc length equals nominal
- `test_length_penalty_outside_tolerance`: penalty > 0 when arc length outside ±30%
- `test_curvature_penalty_straight`: penalty is 0 for collinear control points
- `test_curvature_penalty_sharp_bend`: penalty > 0 for acute bend angle
- `test_smoothness_penalty_straight`: penalty is 0 for evenly-spaced collinear points

**Initialization tests:**
- `test_cold_start_shape`: verify output shape `(K, 3)` for given K
- `test_cold_start_centered`: verify mean of control points is near centroid
- `test_cold_start_length`: verify span of control points matches nominal length

**Integration test (synthetic):**
- `test_optimize_synthetic_fish`: Create a synthetic scenario with 3-4 fake cameras (identity rotation, translated positions, known intrinsics), a known 3D ground-truth spline (simple arc), project it to 2D in each camera to get synthetic skeleton points, then run CurveOptimizer.optimize_midlines() and verify:
  - Output dict is non-empty
  - Control points are within reasonable distance of ground truth
  - Arc length is within 30% of known ground truth
  - mean_residual < 20px
  - This test may need @pytest.mark.slow if it takes >5s

Use the synthetic camera pattern from existing `tests/unit/test_triangulation.py` (cameras at Z=0, water at Z=1.0, identity R, translated t).

All tests should run on CPU (no CUDA requirement for tests).
  </action>
  <verify>
`hatch run test tests/unit/test_curve_optimizer.py -v` — all tests pass.
  </verify>
  <done>
Unit tests cover basis matrix properties, chamfer distance, all loss functions, initialization, and end-to-end synthetic optimization. All tests pass on CPU.
  </done>
</task>

</tasks>

<verification>
1. `hatch run python -c "from aquapose.reconstruction.curve_optimizer import CurveOptimizer, CurveOptimizerConfig"` imports cleanly
2. `hatch run test tests/unit/test_curve_optimizer.py -v` — all unit tests pass
3. `hatch run typecheck` passes for the new module
4. `hatch run lint` passes with no errors
</verification>

<success_criteria>
- CurveOptimizer.optimize_midlines() accepts MidlineSet and returns dict[int, Midline3D] matching the same dataclass contract as triangulate_midlines()
- Synthetic unit test demonstrates convergence from cold start
- All regularization weights are configurable via CurveOptimizerConfig
- Warm-start logic stores and retrieves previous frame solutions
- GPU batching implemented for all-fish parallel optimization
</success_criteria>

<output>
After completion, create `.planning/phases/09-curve-based-optimization-as-a-replacement-for-triangulation/09-01-SUMMARY.md`
</output>
