---
phase: 15-stage-migrations
plan: 04
type: execute
wave: 4
depends_on: [15-03]
files_modified:
  - src/aquapose/core/tracking/__init__.py
  - src/aquapose/core/tracking/types.py
  - src/aquapose/core/tracking/backends/__init__.py
  - src/aquapose/core/tracking/backends/hungarian.py
  - src/aquapose/core/tracking/stage.py
  - src/aquapose/engine/config.py
  - tests/unit/core/tracking/__init__.py
  - tests/unit/core/tracking/test_tracking_stage.py
autonomous: true
requirements: [STG-04]

must_haves:
  truths:
    - TrackingStage satisfies engine.stages.Stage protocol via structural typing
    - "TrackingStage.run(context) reads context.detections (from Stage 1) — NOT context.associated_bundles — and produces context.tracks. This is intentional v1.0-equivalence debt: FishTracker.update() re-derives cross-camera association internally, so Stage 3 output is not consumed by Stage 4. Documented in bug ledger."
    - Hungarian 3D backend maintains persistent FishTrack identities across frames with lifecycle management
    - FishTracker is created once at construction and maintains state across frames (stateful but deterministic)
    - Population constraint preserved — dead track IDs are recycled for new fish
    - No imports from engine/ in any core/tracking/ module
  artifacts:
    - src/aquapose/core/tracking/__init__.py
    - src/aquapose/core/tracking/types.py
    - src/aquapose/core/tracking/stage.py
    - src/aquapose/core/tracking/backends/hungarian.py
    - tests/unit/core/tracking/test_tracking_stage.py
  key_links:
    - "TrackingStage reads PipelineContext.detections (from Stage 1) — NOT PipelineContext.associated_bundles. This is intentional v1.0-equivalence: FishTracker.update() expects raw detections and re-derives association internally. Stage 3 output (associated_bundles) exists as a data product for future backends/observers but is not consumed by Stage 4 in v1.0-equivalent mode."
    - TrackingStage writes PipelineContext.tracks
    - Uses existing aquapose.tracking.tracker.FishTracker for temporal association
    - Tracker is stateful (persists across frames) but logically deterministic given same inputs
---

<objective>
Port the Tracking stage (Stage 4) as a pure Stage Protocol implementor in core/tracking/.

Purpose: Tracking assigns persistent fish identities across frames. It takes per-frame association bundles (from Stage 3) and maintains FishTrack objects with lifecycle management (probationary -> confirmed -> coasting -> dead). In v1.0, tracking and association were combined in FishTracker. In the new model, Stage 3 provides cross-camera bundles per frame; Stage 4 does temporal association (matching bundles to tracks across time).

Key architectural change: v1.0's FishTracker.update() did BOTH cross-camera association (claim_detections_for_tracks, discover_births) AND temporal tracking. The new model separates these: Stage 3 does cross-camera matching, Stage 4 does temporal tracking using the bundles from Stage 3.

Output: A TrackingStage class in core/tracking/ that takes association bundles and maintains persistent fish tracks.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-stage-migrations/15-CONTEXT.md

@src/aquapose/engine/stages.py
@src/aquapose/engine/config.py
@src/aquapose/tracking/tracker.py (v1.0 FishTracker, FishTrack, TrackState — port this behavior)
@src/aquapose/tracking/associate.py (claim_detections_for_tracks, discover_births — now split across Stage 3 and Stage 4)
@src/aquapose/pipeline/stages.py (v1.0 run_tracking — port this behavior)
@src/aquapose/calibration/projection.py (RefractiveProjectionModel)

<interfaces>
<!-- Engine contracts -->
From src/aquapose/engine/stages.py:
```python
@dataclass
class PipelineContext:
    detections: list[dict[str, list]] | None = None
    associated_bundles: list[list] | None = None  # Stage 3 output (input to this stage)
    tracks: list[list] | None = None              # Stage 4 output (this stage writes)
    camera_ids: list[str] | None = None
```

From src/aquapose/engine/config.py:
```python
@dataclass(frozen=True)
class TrackingConfig:
    max_fish: int = 9
```

<!-- v1.0 tracker API (to be wrapped, not reimplemented) -->
From src/aquapose/tracking/tracker.py:
```python
class FishTracker:
    def __init__(self, min_hits=5, max_age=7, expected_count=9, ...): ...
    def update(self, detections_per_camera, models, frame_index) -> list[FishTrack]: ...

@dataclass
class FishTrack:
    fish_id: int
    positions: deque[np.ndarray]  # recent 3D centroids
    velocity: np.ndarray
    state: TrackState
    camera_detections: dict[str, int]
    # ...
```

<!-- Association output (Stage 3) that this stage consumes -->
From core/association/types.py (created in Plan 15-03):
```python
@dataclass
class AssociationBundle:
    fish_idx: int
    centroid_3d: np.ndarray
    camera_detections: dict[str, int]
    n_cameras: int
    reprojection_residual: float
    confidence: float
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create core/tracking/ module with Hungarian backend and stage</name>
  <files>
    src/aquapose/core/tracking/__init__.py
    src/aquapose/core/tracking/types.py
    src/aquapose/core/tracking/backends/__init__.py
    src/aquapose/core/tracking/backends/hungarian.py
    src/aquapose/core/tracking/stage.py
    src/aquapose/engine/config.py
  </files>
  <action>
Create the core/tracking/ package:

1. **types.py** — Re-export `FishTrack`, `TrackState` from `aquapose.tracking.tracker`. These are the canonical track types used by downstream stages.

2. **backends/__init__.py** — Backend registry. Only "hungarian" supported. Raise ValueError for unknown.

3. **backends/hungarian.py** — Hungarian 3D tracking backend:
   - Constructor accepts `calibration_path: str | Path`, `expected_count: int = 9`, plus all FishTracker parameters (min_hits, max_age, reprojection_threshold, birth_interval, etc.) — extract from v1.0 defaults
   - Creates a FishTracker instance at construction (stateful, persists across frames)
   - Loads calibration to build RefractiveProjectionModel dict (needed for tracker.update())
   - Exposes `track_frame(frame_idx: int, bundles: list[AssociationBundle], detections_per_camera: dict[str, list[Detection]]) -> list[FishTrack]`:
     - The key design challenge: v1.0 FishTracker.update() expects raw detections_per_camera and does its own cross-camera association internally. But in the new model, Stage 3 already did cross-camera association.
     - APPROACH: For v1.0 behavioral equivalence, pass raw detections_per_camera to tracker.update() directly. The tracker's internal claim_detections_for_tracks() and discover_births() will re-do the association work, which is redundant but preserves exact v1.0 behavior. This is intentional — port behavior, not rewrite logic.
     - The associated_bundles from Stage 3 are NOT consumed by this backend directly in v1.0-equivalent mode. They exist as a data product for future backends or observers.
     - Returns list of confirmed FishTrack objects from this frame

   IMPORTANT BEHAVIORAL NOTE: To preserve exact v1.0 numerical equivalence, this backend should pass raw detections and models to the existing FishTracker.update() method. The associated_bundles output from Stage 3 is a "read-only" data product — the Tracking stage consumes detections directly. This is a v1.0 quirk preserved intentionally. Document in the bug ledger as a known design debt: "Stage 3 output not consumed by Stage 4 — Stage 4 re-derives association internally via FishTracker.update() to preserve v1.0 equivalence."

4. **stage.py** — `TrackingStage` class satisfying Stage Protocol:
   - Constructor: accepts `calibration_path: str | Path`, `expected_count: int = 9`, `skip_camera_id: str = "e3v8250"`, `backend: str = "hungarian"`, plus tracker kwargs
   - Creates the selected backend at construction
   - `run(self, context)`:
     - Reads context.detections (raw per-frame per-camera detection dicts)
     - For each frame, calls backend.track_frame()
     - Sets context.tracks = list of per-frame confirmed track lists
     - Returns context

   CRITICAL: core/tracking/ must NOT import from engine/.

5. **__init__.py** — Export TrackingStage, FishTrack, TrackState.

6. **engine/config.py** — Extend TrackingConfig with tracker parameters:
   ```python
   @dataclass(frozen=True)
   class TrackingConfig:
       max_fish: int = 9
       min_hits: int = 5
       max_age: int = 7
       reprojection_threshold: float = 15.0
       birth_interval: int = 30
       min_cameras_birth: int = 3
       velocity_damping: float = 0.8
       velocity_window: int = 5
   ```
  </action>
  <verify>
    <automated>hatch run python -c "from aquapose.core.tracking import TrackingStage, FishTrack, TrackState; print('imports OK')"</automated>
  </verify>
  <done>
    - TrackingStage exists in core/tracking/stage.py
    - Hungarian backend wraps existing FishTracker preserving v1.0 behavior exactly
    - run() populates context.tracks from context.detections
    - Tracker state persists across frames (stateful construction)
    - No imports from engine/ in core/tracking/
  </done>
</task>

<task type="auto">
  <name>Task 2: Interface tests for TrackingStage</name>
  <files>
    tests/unit/core/tracking/__init__.py
    tests/unit/core/tracking/test_tracking_stage.py
  </files>
  <action>
Create interface tests:

1. **test_tracking_stage_satisfies_protocol** — Assert isinstance(stage, Stage) passes.

2. **test_tracking_stage_populates_tracks** — Create stage with mocked calibration/models. Feed synthetic detections across multiple frames. Assert context.tracks is populated as list of per-frame lists.

3. **test_tracking_state_persists_across_frames** — Verify that running multiple frames through the same TrackingStage produces persistent fish_id assignments (tracks carry over, not reset each frame).

4. **test_backend_registry_unknown_raises** — Assert ValueError for unknown backend kind.

5. **test_import_boundary** — Inspect source of all modules in core/tracking/ and assert no imports from aquapose.engine.

6. **test_tracks_have_required_attributes** — Verify FishTrack objects in output have fish_id, positions, state attributes.

Mock the FishTracker and calibration loading for unit tests. Use synthetic data to test the stage wiring.
  </action>
  <verify>
    <automated>hatch run test tests/unit/core/tracking/test_tracking_stage.py -x -v</automated>
  </verify>
  <done>
    - All tests pass
    - TrackingStage confirmed to satisfy Stage Protocol
    - Tracker state persistence verified
    - Import boundary verified
  </done>
</task>

</tasks>

<verification>
1. `isinstance(TrackingStage(...), Stage)` returns True
2. `hatch run test tests/unit/core/tracking/ -v` — all pass
3. `hatch run check` — no lint or type errors
4. grep for "engine" in src/aquapose/core/tracking/ returns nothing
</verification>

<success_criteria>
- TrackingStage satisfies Stage Protocol via structural typing
- Hungarian backend wraps FishTracker, preserving v1.0 behavior exactly
- Tracker state persists across frames (fish_id continuity)
- run() populates context.tracks
- Interface tests pass
- No engine/ imports in core/tracking/
</success_criteria>

<output>
After completion, create `.planning/phases/15-stage-migrations/15-04-SUMMARY.md`
</output>
