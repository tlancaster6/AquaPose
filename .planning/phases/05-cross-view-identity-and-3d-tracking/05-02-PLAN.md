---
phase: 05-cross-view-identity-and-3d-tracking
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/aquapose/tracking/tracker.py
  - src/aquapose/tracking/__init__.py
  - tests/unit/tracking/test_tracker.py
autonomous: true
requirements:
  - TRACK-03
  - TRACK-04

must_haves:
  truths:
    - "Hungarian assignment on 3D centroids maintains persistent fish IDs across frames"
    - "Track lifecycle manages birth (2-frame confirmation), active updates, grace period (7 frames), and death"
    - "Population constraint links lost tracks to new detections appearing in the same frame window"
    - "Constant-velocity motion model predicts next-frame position for cost matrix"
    - "XY-only distance used in Hungarian cost matrix to avoid Z-noise ID swaps"
  artifacts:
    - path: "src/aquapose/tracking/tracker.py"
      provides: "FishTracker with Hungarian assignment and track lifecycle"
      exports: ["FishTrack", "FishTracker"]
    - path: "tests/unit/tracking/test_tracker.py"
      provides: "Unit tests for tracker lifecycle and Hungarian assignment"
  key_links:
    - from: "src/aquapose/tracking/tracker.py"
      to: "src/aquapose/tracking/associate.py"
      via: "consumes FrameAssociations from ransac_centroid_cluster"
      pattern: "from .associate import"
    - from: "src/aquapose/tracking/tracker.py"
      to: "scipy.optimize.linear_sum_assignment"
      via: "Hungarian algorithm for optimal bipartite matching"
      pattern: "from scipy.optimize import linear_sum_assignment"
---

<objective>
Implement temporal tracking with Hungarian assignment and track lifecycle management.

Purpose: Given per-frame spatial associations from Plan 01's RANSAC clustering, this plan maintains persistent fish IDs across frames using a SORT-derived tracker. Fish rarely swap positions in 3D, so a constant-velocity prediction + Hungarian matching in XY space provides robust temporal continuity for 9 fish.

Output: `src/aquapose/tracking/tracker.py` with `FishTrack` and `FishTracker` classes, plus unit tests.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-cross-view-identity-and-3d-tracking/05-CONTEXT.md
@.planning/phases/05-cross-view-identity-and-3d-tracking/05-RESEARCH.md
@.planning/phases/05-cross-view-identity-and-3d-tracking/05-01-SUMMARY.md

@src/aquapose/tracking/associate.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement FishTrack and FishTracker with Hungarian assignment</name>
  <files>
    src/aquapose/tracking/tracker.py
    src/aquapose/tracking/__init__.py
  </files>
  <action>
**`tracker.py`** — Track lifecycle and temporal assignment:

1. **Constants** (module-level, configurable via FishTracker constructor):
   - `DEFAULT_MIN_HITS = 2` — frames before track is confirmed (CONTEXT: 2-3 frames)
   - `DEFAULT_MAX_AGE = 7` — grace period frames before track death (CONTEXT: 5-10 frames)
   - `DEFAULT_MAX_DISTANCE = 0.1` — meters; XY-only Hungarian cost gate (research: fish move ~0.5-1.5cm/frame)

2. **`FishTrack` dataclass**:
   - `fish_id: int`
   - `positions: deque[np.ndarray]` (maxlen=2, for constant-velocity prediction)
   - `age: int` — total frames since creation
   - `hit_streak: int` — consecutive frames matched
   - `frames_since_update: int` — frames since last match
   - `is_confirmed: bool` — True after `hit_streak >= min_hits`
   - `camera_detections: dict[str, int]` — latest frame's camera→detection_id mapping
   - `bboxes: dict[str, tuple[int, int, int, int]]` — latest frame's per-camera bboxes
   - `reprojection_residual: float` — latest association residual
   - `confidence: float` — latest association confidence
   - `n_cameras: int` — latest number of cameras seeing this fish
   - Methods:
     - `predict() -> np.ndarray`: constant-velocity from 2-frame deque. If only 1 position, return copy. Returns 3D point.
     - `update(association: AssociationResult) -> None`: append position, reset `frames_since_update`, increment `hit_streak`, update camera_detections/bboxes/residual/confidence/n_cameras, set `is_confirmed` if streak >= min_hits
     - `mark_missed() -> None`: increment `frames_since_update`, reset `hit_streak` to 0, increment `age`
     - `is_dead` property: `frames_since_update > max_age`

3. **`FishTracker` class**:
   - Constructor: `__init__(self, min_hits=DEFAULT_MIN_HITS, max_age=DEFAULT_MAX_AGE, max_distance=DEFAULT_MAX_DISTANCE, expected_count=9)`
   - State: `self.tracks: list[FishTrack]`, `self._next_id: int = 0`, `self.frame_count: int = 0`
   - `update(frame_associations: FrameAssociations) -> list[FishTrack]`:
     1. **Predict**: call `track.predict()` for each active track
     2. **Build cost matrix**: XY-only Euclidean distance between predicted positions and observed 3D centroids from `frame_associations.associations`. Use `np.linalg.norm(pred[:2] - obs[:2])`. Fill with `max_distance + 1.0` for uncomputed entries.
     3. **Hungarian solve**: `scipy.optimize.linear_sum_assignment(cost_matrix)` → row/col indices
     4. **Gate**: reject matches where `cost[r, c] > max_distance` → these go to unmatched
     5. **Update matched tracks**: call `track.update(association)`
     6. **Mark unmatched tracks**: call `track.mark_missed()`
     7. **TRACK-04 population constraint**: if a track died this frame AND there's an unmatched observation in the same frame, link them (re-use the dead track's fish_id for the new observation instead of assigning a new ID)
     8. **Create new tracks**: for remaining unmatched observations, create tentative `FishTrack` with next ID
     9. **Prune dead tracks**: remove tracks where `is_dead` is True (after linking step)
     10. Return list of all confirmed tracks (where `is_confirmed` is True)
   - `get_all_tracks() -> list[FishTrack]`: return all tracks including tentative ones
   - `get_seed_points() -> list[np.ndarray] | None`: return latest positions of confirmed tracks for prior-guided RANSAC. Return None if no confirmed tracks (frame 0).

   **First-frame initialization (Claude's discretion — batch)**: On frame 0, all associations create new tracks directly. Sort initial IDs by X coordinate of 3D centroid for deterministic ordering. From frame 1 onward, Hungarian assignment takes over.

**Update `__init__.py`**: Add `FishTrack`, `FishTracker` to imports and `__all__`.
  </action>
  <verify>
    `hatch run check` passes. `python -c "from aquapose.tracking import FishTracker, FishTrack"` succeeds.
  </verify>
  <done>
    `FishTracker` implements Hungarian assignment with XY-only cost, constant-velocity prediction, SORT-derived lifecycle (MIN_HITS=2, MAX_AGE=7), and TRACK-04 population constraint linking dead tracks to new observations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for tracker lifecycle and Hungarian assignment</name>
  <files>
    tests/unit/tracking/test_tracker.py
  </files>
  <action>
**Test cases** (all synthetic, no GPU):

1. **`test_single_fish_track_across_frames`**: Create 5 sequential `FrameAssociations` with one fish moving linearly in 3D. Feed to `FishTracker.update()`. Assert: same `fish_id` maintained across all 5 frames, `is_confirmed` True after frame 2 (MIN_HITS=2).

2. **`test_two_fish_no_swap`**: Two fish moving in opposite directions. 10 frames. Assert: fish IDs are stable — fish_0 stays fish_0, no swaps.

3. **`test_birth_confirmation`**: New fish appears. Assert: `is_confirmed=False` for first frame, `is_confirmed=True` after `min_hits` consecutive updates.

4. **`test_grace_period_and_death`**: Fish disappears for 8 frames. Assert: track still alive at frame 7 (`frames_since_update=7`), dead at frame 8 (`frames_since_update=8 > MAX_AGE=7`).

5. **`test_population_constraint_relinking`**: Fish A disappears. Same frame, new observation appears. Assert: new observation gets fish A's ID (not a fresh ID), per TRACK-04.

6. **`test_constant_velocity_prediction`**: Fish at positions [0,0,0] then [1,0,0]. Assert: `predict()` returns [2,0,0].

7. **`test_xy_only_cost_matrix`**: Two fish at same XY but different Z. Two observations at same XY but swapped Z. Assert: Hungarian matches correctly despite Z swap (because cost is XY-only).

8. **`test_max_distance_gate`**: One track, one observation 1.0m away in XY (>> max_distance=0.1m). Assert: no match made, track goes to unmatched, observation creates new track.

9. **`test_first_frame_batch_init`**: 9 associations on frame 0. Assert: 9 tracks created, IDs sorted by X coordinate.

10. **`test_get_seed_points`**: After 3 frames with confirmed tracks, `get_seed_points()` returns list of 3D centroids. On frame 0 (no tracks), returns None.

Use helper functions to create synthetic `AssociationResult` and `FrameAssociations` objects. No mocking of scipy — it's fast enough for 9x9 matrices.
  </action>
  <verify>
    `hatch run test tests/unit/tracking/test_tracker.py` — all tests pass.
  </verify>
  <done>
    10 unit tests covering: single-fish tracking, two-fish stability, birth confirmation, grace period/death, population constraint relinking (TRACK-04), constant-velocity prediction, XY-only cost, max-distance gate, batch initialization, seed point retrieval. All pass.
  </done>
</task>

</tasks>

<verification>
- `hatch run check` passes (lint + typecheck)
- `hatch run test tests/unit/tracking/` — all tests pass (Plan 01 + Plan 02 tests)
- Hungarian assignment correctly uses XY-only distance
- Track lifecycle: birth (2 frames) → active → grace (7 frames) → death
- Population constraint (TRACK-04) links dead tracks to new observations
</verification>

<success_criteria>
- Persistent fish IDs maintained across synthetic multi-frame sequences
- No ID swaps when fish are spatially separated
- Population constraint prevents ID inflation when fish are temporarily lost
- XY-only cost avoids Z-noise induced ID swaps
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-cross-view-identity-and-3d-tracking/05-02-SUMMARY.md`
</output>
