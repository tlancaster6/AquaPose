---
phase: 18-cli-and-execution-modes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/aquapose/cli.py
  - src/aquapose/engine/console_observer.py
  - src/aquapose/engine/__init__.py
  - tests/unit/engine/test_cli.py
  - tests/unit/engine/test_console_observer.py
autonomous: true
requirements: [CLI-01, CLI-02]

must_haves:
  truths:
    - "`aquapose run --config path.yaml` parses args, builds config, assembles observers, calls PosePipeline.run(), and exits 0 on success"
    - "Production mode (default) attaches TimingObserver + HDF5ExportObserver"
    - "CLI layer contains zero reconstruction logic — only arg parsing, config loading, observer assembly, and pipeline invocation"
    - "Console output shows stage-level progress as each stage starts/completes with timing"
    - "`--set key=val` feeds dot-notation overrides into load_config()"
    - "Exit code 1 on failure, error details to stderr"
  artifacts:
    - path: "src/aquapose/cli.py"
      provides: "Click-based CLI entrypoint with `aquapose run` command"
      contains: "def run"
    - path: "src/aquapose/engine/console_observer.py"
      provides: "ConsoleObserver printing stage progress and completion summary"
      contains: "class ConsoleObserver"
    - path: "pyproject.toml"
      provides: "Click dependency and [project.scripts] entry point"
      contains: "[project.scripts]"
    - path: "tests/unit/engine/test_cli.py"
      provides: "CLI unit tests using Click CliRunner"
    - path: "tests/unit/engine/test_console_observer.py"
      provides: "ConsoleObserver unit tests"
  key_links:
    - from: "src/aquapose/cli.py"
      to: "aquapose.engine.config.load_config"
      via: "load_config(yaml_path, cli_overrides=overrides)"
      pattern: "load_config"
    - from: "src/aquapose/cli.py"
      to: "aquapose.engine.pipeline.PosePipeline"
      via: "PosePipeline(stages, config, observers).run()"
      pattern: "PosePipeline"
    - from: "src/aquapose/cli.py"
      to: "aquapose.engine.pipeline.build_stages"
      via: "build_stages(config) for stage construction"
      pattern: "build_stages"
    - from: "pyproject.toml"
      to: "src/aquapose/cli.py"
      via: "[project.scripts] aquapose = aquapose.cli:main"
      pattern: "aquapose.cli:main"
---

<objective>
Create the `aquapose run` CLI entrypoint as a thin wrapper over PosePipeline, with production mode as the default, and a ConsoleObserver for stage-level progress output.

Purpose: This is the final user-facing layer of the v2.0 architecture — the single command that users invoke to run the pipeline. It must be purely a thin wrapper: parse args, build config, assemble observers, call run().

Output: Working `aquapose run --config path.yaml` command with console progress output, `--set` overrides, `--verbose` flag, and `--add-observer` for additive observer attachment.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-cli-and-execution-modes/18-CONTEXT.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/aquapose/engine/config.py:
```python
def load_config(
    yaml_path: str | Path | None = None,
    *,
    cli_overrides: dict[str, Any] | None = None,
    run_id: str | None = None,
) -> PipelineConfig:
    """Construct a frozen PipelineConfig using layered overrides."""

@dataclass(frozen=True)
class PipelineConfig:
    run_id: str = ""
    output_dir: str = ""
    video_dir: str = ""
    calibration_path: str = ""
    mode: str = "production"
    detection: DetectionConfig = ...
    midline: MidlineConfig = ...
    association: AssociationConfig = ...
    tracking: TrackingConfig = ...
    reconstruction: ReconstructionConfig = ...
```

From src/aquapose/engine/pipeline.py:
```python
class PosePipeline:
    def __init__(
        self,
        stages: list[Stage],
        config: PipelineConfig,
        observers: list[Observer] | None = None,
    ) -> None: ...

    def run(self) -> PipelineContext: ...

def build_stages(config: PipelineConfig) -> list[Stage]: ...
```

From src/aquapose/engine/events.py:
```python
@dataclass(frozen=True)
class StageStart(Event):
    stage_name: str = ""
    stage_index: int = 0

@dataclass(frozen=True)
class StageComplete(Event):
    stage_name: str = ""
    stage_index: int = 0
    elapsed_seconds: float = 0.0
    summary: dict[str, object] = ...
    context: object = ...

@dataclass(frozen=True)
class PipelineComplete(Event):
    run_id: str = ""
    elapsed_seconds: float = 0.0
    context: object = ...

@dataclass(frozen=True)
class PipelineFailed(Event):
    run_id: str = ""
    error: str = ""
    elapsed_seconds: float = 0.0
```

From src/aquapose/engine/timing.py:
```python
class TimingObserver:
    def __init__(self, output_path: str | Path | None = None) -> None: ...
```

From src/aquapose/engine/hdf5_observer.py:
```python
class HDF5ExportObserver:
    def __init__(self, output_dir: str | Path) -> None: ...
```

From src/aquapose/engine/observers.py:
```python
@runtime_checkable
class Observer(Protocol):
    def on_event(self, event: Event) -> None: ...
```

From pyproject.toml (currently commented out):
```toml
# [project.scripts]
# aquapose = "aquapose.cli:main"
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ConsoleObserver and CLI entrypoint module</name>
  <files>
    src/aquapose/engine/console_observer.py
    src/aquapose/engine/__init__.py
    src/aquapose/cli.py
    pyproject.toml
  </files>
  <action>
**1. Add Click dependency to pyproject.toml:**
- Add `"click>=8.1"` to the `dependencies` list.
- Uncomment and update `[project.scripts]` to: `aquapose = "aquapose.cli:main"`

**2. Create `src/aquapose/engine/console_observer.py`:**
- `class ConsoleObserver` with `__init__(self, verbose: bool = False, total_stages: int = 5)`.
- Implements `on_event(self, event: Event) -> None`.
- On `StageStart`: prints `[{stage_index+1}/{total_stages}] {stage_name}...` to stderr (stderr keeps stdout clean for piping).
- On `StageComplete`: prints ` done ({elapsed_seconds:.1f}s)` to stderr on same conceptual line. Use `\r` or print start without newline and complete with newline. Simplest: print `[1/5] DetectionStage... done (12.3s)` as one line on StageComplete.
- On `PipelineComplete`: prints blank line then `Run complete: {output_dir} ({elapsed:.1f}s)` to stderr. Extract output_dir from PipelineStart config (store it in `_output_dir` on PipelineStart).
- On `PipelineFailed`: prints `Run FAILED after {elapsed:.1f}s: {error}` to stderr.
- If `verbose=True`, on `FrameProcessed` events print per-frame detail line to stderr.
- Use `sys.stderr.write()` for output (not print) to avoid buffering issues and keep stdout clean.
- Add `ConsoleObserver` to `src/aquapose/engine/__init__.py` imports and `__all__`.

**3. Create `src/aquapose/cli.py`:**
- Module docstring: `"""AquaPose CLI — thin wrapper over PosePipeline."""`
- Use Click decorators. Define a Click group `cli` and a single command `run`.
- `@cli.command()` for `run` with these Click options:
  - `--config` (`-c`): Required, type=click.Path(exists=True), help="Path to pipeline config YAML"
  - `--mode` (`-m`): Optional, type=click.Choice(["production", "diagnostic", "benchmark", "synthetic"]), default="production"
  - `--set`: Multiple=True, help="Config override as key=val (e.g. --set detection.detector_kind=mog2)". Parse each `--set` value by splitting on first `=` into key/value. Collect into a dict for `cli_overrides`.
  - `--add-observer`: Multiple=True, type=click.Choice(["timing", "hdf5", "overlay2d", "animation3d", "diagnostic", "console"]), help="Add observer by name"
  - `--verbose` (`-v`): Flag, default=False
- `run()` function logic (the ONLY logic in the CLI — no pipeline computation):
  1. Parse `--set` values into `cli_overrides` dict (dot-notation keys).
  2. Also inject `cli_overrides["mode"] = mode` so the config knows the mode.
  3. Call `load_config(yaml_path=config, cli_overrides=cli_overrides)` to get `PipelineConfig`.
  4. Call `build_stages(config)` to get stages.
  5. Assemble observers based on mode:
     - Always include `ConsoleObserver(verbose=verbose, total_stages=len(stages))`.
     - Production: add `TimingObserver(output_path=output_dir/"timing.txt")`, `HDF5ExportObserver(output_dir=config.output_dir)`.
     - Other modes handled in Plan 18-02 and 18-03.
  6. If `--add-observer` flags present, add those observers additively (resolve name to class, instantiate with sensible defaults using config.output_dir).
  7. Create `PosePipeline(stages=stages, config=config, observers=observers)`.
  8. Wrap `pipeline.run()` in try/except. On success: `sys.exit(0)`. On exception: print error to stderr, `sys.exit(1)`.
- `def main(): cli()` as the entry point function.
- Observer name to class mapping as a module-level dict `_OBSERVER_MAP`.
- Import from `aquapose.engine` only — maintain the import boundary.

**IMPORTANT constraints:**
- The CLI module must contain ZERO reconstruction, detection, segmentation, or any pipeline computation logic.
- All logic is: parse args -> build config -> build stages -> build observers -> call run().
- No interactive prompts. Clean exit codes. Errors to stderr.
  </action>
  <verify>
    <automated>cd C:/Users/tucke/PycharmProjects/AquaPose && python -c "from aquapose.cli import cli; print('CLI import OK')" && python -c "from aquapose.engine.console_observer import ConsoleObserver; print('ConsoleObserver import OK')"</automated>
  </verify>
  <done>
    - `aquapose.cli` module exists with Click-based `run` command
    - ConsoleObserver prints stage progress to stderr
    - pyproject.toml has Click dependency and `[project.scripts]` entry point
    - CLI contains no pipeline computation logic
    - Production mode assembles TimingObserver + HDF5ExportObserver + ConsoleObserver
  </done>
</task>

<task type="auto">
  <name>Task 2: Write unit tests for CLI and ConsoleObserver</name>
  <files>
    tests/unit/engine/test_cli.py
    tests/unit/engine/test_console_observer.py
  </files>
  <action>
**1. Create `tests/unit/engine/test_console_observer.py`:**
- Test ConsoleObserver handles StageStart/StageComplete events and produces expected output.
- Use `io.StringIO` or capture stderr to verify output format.
- Test that `[1/5] DetectionStage... done (12.3s)` format appears on StageComplete.
- Test PipelineComplete prints summary with output dir and total time.
- Test PipelineFailed prints failure message.
- Test verbose=True with FrameProcessed events produces per-frame output.
- Test verbose=False with FrameProcessed events produces no output.

**2. Create `tests/unit/engine/test_cli.py`:**
- Use `click.testing.CliRunner` to invoke the CLI in isolation.
- Test `run --help` returns 0 and shows expected options (--config, --mode, --set, --add-observer, --verbose).
- Test `run` without --config returns non-zero exit code (missing required arg).
- Test `--set` parsing: verify that `--set detection.detector_kind=mog2 --set tracking.max_age=10` produces correct cli_overrides dict. Do this by mocking `load_config` and `build_stages` and `PosePipeline` to capture the args passed.
- Test mode defaults to "production" when not specified.
- Test `--mode diagnostic` sets mode correctly in overrides.
- Test `--add-observer timing` adds TimingObserver to observer list.
- Mock `load_config`, `build_stages`, and `PosePipeline` to avoid needing real video/calibration files. Use `unittest.mock.patch` to intercept calls and verify arguments.
- Test exit code 0 on successful pipeline run (mocked).
- Test exit code 1 on pipeline failure (mocked to raise).

All tests must be runnable without GPU, video files, or calibration data.
  </action>
  <verify>
    <automated>cd C:/Users/tucke/PycharmProjects/AquaPose && python -m pytest tests/unit/engine/test_cli.py tests/unit/engine/test_console_observer.py -x -v</automated>
  </verify>
  <done>
    - ConsoleObserver tests verify output format for all event types
    - CLI tests verify argument parsing, mode selection, observer assembly, and exit codes
    - All tests pass without real pipeline execution (fully mocked)
    - Tests confirm CLI is a pure wrapper with no computation logic
  </done>
</task>

</tasks>

<verification>
1. `python -c "from aquapose.cli import cli"` succeeds (import check)
2. `python -c "from aquapose.engine import ConsoleObserver"` succeeds
3. `python -m pytest tests/unit/engine/test_cli.py tests/unit/engine/test_console_observer.py -x -v` all pass
4. `grep -c "def run\|def detect\|def triangulate\|def reconstruct" src/aquapose/cli.py` returns exactly 1 (only `run`, no computation functions)
5. `grep "aquapose.cli:main" pyproject.toml` confirms entry point is registered
</verification>

<success_criteria>
- `aquapose run --config path.yaml` is a working command that parses args, loads config, builds stages, assembles production-mode observers, and calls PosePipeline.run()
- ConsoleObserver provides human-readable stage progress to stderr
- CLI contains zero pipeline computation logic
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/18-cli-and-execution-modes/18-01-SUMMARY.md`
</output>
