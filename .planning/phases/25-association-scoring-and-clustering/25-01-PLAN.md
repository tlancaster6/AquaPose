---
phase: 25-association-scoring-and-clustering
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/aquapose/core/association/scoring.py
  - src/aquapose/engine/config.py
  - src/aquapose/core/association/__init__.py
  - tests/unit/core/association/test_scoring.py
autonomous: true
requirements: [ASSOC-01]

must_haves:
  truths:
    - "Pairwise affinity score computed for cross-camera tracklet pairs using ray-ray closest-point distance aggregated over shared frames"
    - "Ghost-point penalty multiplicatively suppresses coincidental ray intersections using inverse LUT visibility checks"
    - "Camera overlap graph restricts scoring to adjacent camera pairs only"
    - "Early termination skips pairs with insufficient overlap or zero inliers in initial frames"
    - "AssociationConfig exposes all scoring thresholds as YAML-tunable fields"
  artifacts:
    - path: "src/aquapose/core/association/scoring.py"
      provides: "Pairwise tracklet scoring with ray-ray distance, ghost penalty, early termination"
      exports: ["ray_ray_closest_point", "score_tracklet_pair", "score_all_pairs", "AssociationConfigLike"]
    - path: "src/aquapose/engine/config.py"
      provides: "AssociationConfig with scoring thresholds"
      contains: "class AssociationConfig"
    - path: "tests/unit/core/association/test_scoring.py"
      provides: "Unit tests for scoring functions"
      min_lines: 100
  key_links:
    - from: "src/aquapose/core/association/scoring.py"
      to: "src/aquapose/calibration/luts.py"
      via: "ForwardLUT.cast_ray() for ray back-projection, ghost_point_lookup() for negative evidence"
      pattern: "forward_luts.*cast_ray|ghost_point_lookup"
    - from: "src/aquapose/core/association/scoring.py"
      to: "src/aquapose/core/tracking/types.py"
      via: "Tracklet2D.frames, centroids, frame_status for shared-frame iteration"
      pattern: "tracklet\\.frames|tracklet\\.centroids"
    - from: "src/aquapose/engine/config.py"
      to: "src/aquapose/core/association/scoring.py"
      via: "AssociationConfig satisfies AssociationConfigLike Protocol structurally"
      pattern: "AssociationConfigLike"
---

<objective>
Implement pairwise cross-camera tracklet affinity scoring using ray-ray geometry and ghost-point penalties. This is SPECSEED Steps 0-1 (camera overlap graph filtering + pairwise scoring with aggregation and early termination).

Purpose: Provides the weighted affinity graph that Leiden clustering (Plan 25-02) uses to group tracklets into fish identities. Without accurate pairwise scores, clustering produces wrong groups.

Output: `scoring.py` module with `ray_ray_closest_point()`, `score_tracklet_pair()`, `score_all_pairs()` functions; expanded `AssociationConfig` with all scoring thresholds; unit tests.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-refractive-lookup-tables/23-01-SUMMARY.md
@.planning/phases/23-refractive-lookup-tables/23-02-SUMMARY.md
@.planning/phases/24-per-camera-2d-tracking/24-01-SUMMARY.md
@.planning/phases/22-pipeline-scaffolding/22-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/aquapose/core/tracking/types.py:
```python
@dataclass(frozen=True)
class Tracklet2D:
    camera_id: str
    track_id: int
    frames: tuple        # tuple[int, ...]
    centroids: tuple     # tuple[tuple[float, float], ...]
    bboxes: tuple        # tuple[tuple[float, float, float, float], ...]
    frame_status: tuple  # tuple[str, ...] — "detected" or "coasted"
```

From src/aquapose/core/association/types.py:
```python
@dataclass(frozen=True)
class TrackletGroup:
    fish_id: int
    tracklets: tuple     # tuple[Tracklet2D, ...] (generic tuple at runtime)
    confidence: float | None = None
```

From src/aquapose/calibration/luts.py:
```python
class ForwardLUT:
    grid_origins: np.ndarray    # shape (H, W, 3), float32
    grid_directions: np.ndarray # shape (H, W, 3), float32
    grid_step: int
    def cast_ray(self, pixels: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:
        # pixels: (N, 2) -> (origins (N,3), directions (N,3))

def camera_overlap_graph(inverse_lut: InverseLUT, min_shared_voxels: int = 100) -> dict[tuple[str, str], int]:
    # Returns {(cam_a, cam_b): shared_voxel_count} for adjacent pairs

def ghost_point_lookup(inverse_lut: InverseLUT, points_3d: torch.Tensor) -> list[list[tuple[str, float, float]]]:
    # Returns per-point list of (camera_id, pixel_u, pixel_v) for cameras that see the voxel
```

From src/aquapose/engine/config.py (current stub):
```python
@dataclass(frozen=True)
class AssociationConfig:
    """Config for the Association stage (stub in v2.1 Phase 22)."""
    # Empty — will be populated in this plan
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand AssociationConfig and implement scoring functions</name>
  <files>
    src/aquapose/engine/config.py
    src/aquapose/core/association/scoring.py
    src/aquapose/core/association/__init__.py
  </files>
  <action>
**Step 1: Expand AssociationConfig in engine/config.py**

Replace the empty `AssociationConfig` stub with full scoring parameters. All thresholds from CONTEXT.md decisions:

```python
@dataclass(frozen=True)
class AssociationConfig:
    """Config for the Association stage (Stage 3).

    Attributes:
        ray_distance_threshold: Maximum ray-ray closest-point distance (metres)
            to classify a frame as an inlier. Default 0.03 (3cm — fish are ~10cm
            long, ~2cm wide; 3cm accommodates centroid jitter).
        score_min: Minimum affinity score to create a graph edge. Default 0.3.
        t_min: Minimum shared frames for a tracklet pair to be scored. Default 10.
        t_saturate: Frame count at which overlap reliability saturates. Default 100.
        early_k: Number of initial frames for early termination check. Default 10.
        expected_fish_count: Number of fish in the tank (fixed). Default 9.
        ghost_pixel_threshold: Max pixel distance for a detection to count as
            "supporting" in ghost penalty. Default 50.0.
        min_shared_voxels: Minimum shared voxels for camera pair adjacency. Default 100.
        leiden_resolution: Resolution parameter for Leiden clustering. Default 1.0.
        max_merge_gap: Maximum frame gap for fragment merging. Default 30.
    """
    ray_distance_threshold: float = 0.03
    score_min: float = 0.3
    t_min: int = 10
    t_saturate: int = 100
    early_k: int = 10
    expected_fish_count: int = 9
    ghost_pixel_threshold: float = 50.0
    min_shared_voxels: int = 100
    leiden_resolution: float = 1.0
    max_merge_gap: int = 30
```

**Step 2: Create src/aquapose/core/association/scoring.py**

This module implements SPECSEED Steps 0-1. Use an `AssociationConfigLike` Protocol (same pattern as LutConfigLike) to accept the config without importing from engine/ (preserving IB-003 import boundary).

Functions to implement:

1. **`AssociationConfigLike` Protocol** — structural protocol with the scoring fields consumed by this module: `ray_distance_threshold`, `score_min`, `t_min`, `t_saturate`, `early_k`, `ghost_pixel_threshold`, `min_shared_voxels`.

2. **`ray_ray_closest_point(origin_a, dir_a, origin_b, dir_b)`** — Compute the closest point of approach between two 3D rays. Standard analytic formula for two skew lines:
   - Given rays `p + t*d` and `q + s*e`, the closest points are found by solving the 2x2 linear system from the cross-product formulation.
   - Returns `(distance, midpoint)` where `midpoint` is the average of the two closest points.
   - Input/output are numpy arrays (float32/float64). Keep this function pure numpy — no torch dependency.

3. **`score_tracklet_pair(tracklet_a, tracklet_b, forward_luts, inverse_lut, detections, config)`** — Score a single cross-camera tracklet pair per SPECSEED Step 1:
   - `forward_luts`: dict mapping camera_id to ForwardLUT
   - `inverse_lut`: InverseLUT instance
   - `detections`: per-frame per-camera detection centroids for ghost penalty — `list[dict[str, list[tuple[float, float]]]]` indexed by frame_idx. Each entry maps camera_id to list of detection centroids (u, v) in that frame.
   - `config`: AssociationConfigLike
   - Algorithm:
     a. Find shared frames (intersection of tracklet_a.frames and tracklet_b.frames).
     b. If `len(shared_frames) < config.t_min`, return 0.0.
     c. For each shared frame, back-project centroids via `forward_luts[cam_a].cast_ray()` and `forward_luts[cam_b].cast_ray()`.
     d. Compute `ray_ray_closest_point()` for each shared frame. Record distance d(t) and midpoint P(t).
     e. **Early termination**: After `config.early_k` frames, if inlier count is 0 (no frames with d(t) < config.ray_distance_threshold), return 0.0 immediately.
     f. Compute inlier fraction: f = (frames where d(t) < threshold) / T_shared.
     g. **Ghost penalty** (for each inlier frame):
        - Call `ghost_point_lookup(inverse_lut, midpoint_tensor)` to get visible cameras and expected pixels.
        - For each visible camera (excluding the two scoring cameras): classify as "supporting" if any detection in `detections[frame][cam]` is within `config.ghost_pixel_threshold` pixel distance of expected (u,v), else "negative".
        - g(t) = n_negative / n_visible_excluding_pair. If no other cameras visible, g(t) = 0.
     h. Mean ghost ratio: mean of g(t) over inlier frames.
     i. Overlap reliability: w = min(T_shared, config.t_saturate) / config.t_saturate.
     j. Combined score: s = f * (1 - mean_ghost) * w.
     k. Return the score (float).
   - Use torch tensors for cast_ray calls (ForwardLUT expects torch). Convert back to numpy for ray_ray_closest_point.

4. **`score_all_pairs(tracks_2d, forward_luts, inverse_lut, detections, config)`** — Score all cross-camera tracklet pairs per SPECSEED Steps 0-1:
   - `tracks_2d`: `dict[str, list[Tracklet2D]]` — per-camera tracklets (from PipelineContext).
   - Use `camera_overlap_graph(inverse_lut, config.min_shared_voxels)` to determine adjacent camera pairs.
   - For each adjacent pair and each tracklet combination, call `score_tracklet_pair()`.
   - Filter by `config.score_min`.
   - Return a dict: `{(tracklet_a_key, tracklet_b_key): score}` where each key is `(camera_id, track_id)` — a tuple uniquely identifying a tracklet.
   - Emit a diagnostic warning (via logging) with the count of pairs scored, edges kept, and time elapsed.

**Step 3: Update core/association/__init__.py**

Add exports for the new scoring functions and Protocol to `__init__.py` and `__all__`.

**Import boundary note**: `scoring.py` lives in `core/association/` and MUST NOT import from `engine/`. Use `AssociationConfigLike` Protocol (same pattern as `LutConfigLike` in calibration/luts.py). It CAN import from `calibration/` (ForwardLUT, InverseLUT, ghost_point_lookup, camera_overlap_graph) and from `core/tracking/` (Tracklet2D).
  </action>
  <verify>
    <automated>cd C:/Users/tucke/PycharmProjects/AquaPose && python -c "from aquapose.core.association.scoring import ray_ray_closest_point, score_tracklet_pair, score_all_pairs, AssociationConfigLike; print('imports OK')" && hatch run lint</automated>
  </verify>
  <done>
    - AssociationConfig has all 10 scoring/clustering fields with SPECSEED defaults
    - ray_ray_closest_point returns (distance, midpoint) for two 3D rays
    - score_tracklet_pair implements full SPECSEED Step 1 (ray distance + ghost penalty + early termination + aggregation)
    - score_all_pairs uses camera_overlap_graph for pruning and returns filtered score dict
    - AssociationConfigLike Protocol preserves IB-003 import boundary
    - All new symbols exported from core/association/__init__.py
  </done>
</task>

<task type="auto">
  <name>Task 2: Write unit tests for scoring functions</name>
  <files>
    tests/unit/core/association/test_scoring.py
  </files>
  <action>
Create `tests/unit/core/association/test_scoring.py` with these test cases:

**Test fixtures:**
- Create a minimal `MockForwardLUT` that returns known origins/directions for specific pixel inputs (e.g., two cameras looking at the same 3D point from different angles). Use simple geometry: camera at (0,0,0) looking along +z and camera at (1,0,0) looking along -x+z so rays converge.
- Create a minimal `MockInverseLUT` with a small voxel grid that returns known visibility for ghost penalty tests.
- Create a `MockAssociationConfig` frozen dataclass that satisfies AssociationConfigLike with test values.
- Create helper function to build synthetic Tracklet2D objects with specified frames, centroids, and statuses.

**Tests:**

1. **`test_ray_ray_closest_point_intersecting`** — Two rays that intersect at a known point. Distance should be ~0. Midpoint should be at the intersection point.

2. **`test_ray_ray_closest_point_skew`** — Two skew lines with known closest distance (e.g., rays along x-axis and z-axis offset by 1 unit in y). Distance = 1.0, midpoint halfway.

3. **`test_ray_ray_closest_point_parallel`** — Two parallel rays. Should return a large or inf distance (degenerate case). Ensure no crash.

4. **`test_score_tracklet_pair_perfect_match`** — Two tracklets from different cameras whose centroids back-project to rays that converge within threshold on every frame. Score should be close to 1.0 (high inlier fraction, low ghost ratio, full overlap reliability).

5. **`test_score_tracklet_pair_no_overlap`** — Two tracklets with no shared frames. Score should be 0.0.

6. **`test_score_tracklet_pair_below_t_min`** — Two tracklets sharing fewer than t_min frames. Score should be 0.0.

7. **`test_score_tracklet_pair_early_termination`** — Two tracklets whose rays never converge (large distance). After early_k frames with 0 inliers, should return 0.0 without evaluating remaining frames. (Test by checking that the function runs fast / returns 0.)

8. **`test_score_all_pairs_respects_camera_adjacency`** — Provide tracklets from 3 cameras where only cam_a-cam_b are adjacent (cam_c is not adjacent to either). score_all_pairs should only score cam_a-cam_b pairs, not cam_a-cam_c or cam_b-cam_c.

9. **`test_score_all_pairs_filters_by_score_min`** — Provide tracklets that produce a score below score_min. Result dict should not contain those pairs.

10. **`test_ghost_penalty_suppresses_score`** — Two tracklets whose rays converge but the ghost penalty is high (other cameras don't see detections at the expected location). Score should be significantly lower than without ghost penalty.

For tests 4-10, use mock LUTs with controlled geometry. The ghost penalty tests need a mock inverse LUT that returns specific camera visibility lists and a detections list that either does or doesn't have detections at expected locations.

Ensure `__init__.py` exists in `tests/unit/core/association/` (create if missing).
  </action>
  <verify>
    <automated>cd C:/Users/tucke/PycharmProjects/AquaPose && hatch run test tests/unit/core/association/test_scoring.py -v</automated>
  </verify>
  <done>
    - All 10 tests pass
    - ray_ray_closest_point tested for intersecting, skew, and parallel rays
    - score_tracklet_pair tested for perfect match, no overlap, below t_min, and early termination
    - score_all_pairs tested for camera adjacency filtering and score_min filtering
    - Ghost penalty verified to suppress scores when other cameras contradict
  </done>
</task>

</tasks>

<verification>
```bash
cd C:/Users/tucke/PycharmProjects/AquaPose
hatch run test tests/unit/core/association/test_scoring.py -v
hatch run lint
hatch run test  # full suite still passes
```
</verification>

<success_criteria>
- `ray_ray_closest_point()` returns correct distance and midpoint for known ray geometries
- `score_tracklet_pair()` produces scores following the formula s = f * (1 - ghost) * w with early termination
- `score_all_pairs()` uses camera overlap graph to restrict scoring to adjacent pairs and filters by score_min
- AssociationConfig has all scoring parameters exposed as YAML-tunable frozen dataclass fields
- Import boundary IB-003 preserved via AssociationConfigLike Protocol
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/25-association-scoring-and-clustering/25-01-SUMMARY.md`
</output>
