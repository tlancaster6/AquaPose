---
phase: 13-engine-core
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/aquapose/engine/__init__.py
  - src/aquapose/engine/stages.py
  - tests/unit/engine/__init__.py
  - tests/unit/engine/test_stages.py
autonomous: true
requirements:
  - ENG-01
  - ENG-02
  - ENG-07

must_haves:
  truths:
    - "A class with a conforming run() method is recognized as a Stage via structural typing without inheritance"
    - "PipelineContext is a typed dataclass that accumulates results from stages with no implicit shared state"
    - "engine/ package exists with strict one-way import boundary — engine imports computation, never reverse"
  artifacts:
    - path: "src/aquapose/engine/__init__.py"
      provides: "Engine package public API"
      contains: "__all__"
    - path: "src/aquapose/engine/stages.py"
      provides: "Stage Protocol and PipelineContext dataclass"
      exports: ["Stage", "PipelineContext"]
    - path: "tests/unit/engine/test_stages.py"
      provides: "Tests for Stage protocol conformance and PipelineContext behavior"
      min_lines: 40
  key_links:
    - from: "src/aquapose/engine/stages.py"
      to: "typing.Protocol"
      via: "Stage class inherits Protocol"
      pattern: "class Stage.*Protocol"
    - from: "src/aquapose/engine/stages.py"
      to: "dataclasses.dataclass"
      via: "PipelineContext is a dataclass"
      pattern: "@dataclass"
---

<objective>
Define the Stage Protocol via `typing.Protocol` with structural typing and the PipelineContext typed dataclass that accumulates stage results. Establish the `src/aquapose/engine/` package with its `__init__.py` public API.

Purpose: These are the foundational contracts that all subsequent engine components build on — stages implement the Stage protocol, and PipelineContext is the typed conduit for all inter-stage data flow.
Output: `src/aquapose/engine/stages.py` with Stage Protocol and PipelineContext, plus unit tests proving structural typing works.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-engine-core/13-CONTEXT.md
@src/aquapose/pipeline/stages.py (existing v1.0 stage functions — reference for what PipelineContext fields must eventually hold)
@src/aquapose/pipeline/orchestrator.py (existing v1.0 orchestrator — reference for data flow)

<interfaces>
<!-- No prior engine interfaces exist. This plan creates the foundational contracts. -->
<!-- The executor should reference the existing v1.0 pipeline to understand what data flows between stages. -->

From CONTEXT.md decisions:
- Stage Protocol: `typing.Protocol`, single `run()` method, structurally typed
- Stages are logically stateless but may cache expensive initialization
- Each stage receives only its own config subtree at construction
- PipelineContext: strongly typed dataclass accumulating results stage-by-stage
- Stage ordering: explicit ordered list (not dependency DAG)
- Import boundary: engine/ imports computation modules, NEVER reverse. No TYPE_CHECKING exceptions.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create engine package with Stage Protocol and PipelineContext</name>
  <files>
    src/aquapose/engine/__init__.py
    src/aquapose/engine/stages.py
  </files>
  <action>
Create `src/aquapose/engine/` package:

**`stages.py`:**
1. Define `Stage` as a `typing.Protocol` class with a single method:
   - `run(self, context: PipelineContext) -> PipelineContext`
   - Use `typing.runtime_checkable` decorator so `isinstance()` checks work
2. Define `PipelineContext` as a `@dataclass` with Optional typed fields for each stage's output. Fields should be `None` by default (stages populate them progressively). Based on existing v1.0 data flow (see `src/aquapose/pipeline/stages.py` and `orchestrator.py`), include at minimum:
   - `frame_count: int | None` — number of frames processed
   - `camera_ids: list[str] | None` — active camera IDs
   - `detections: list[dict[str, list]] | None` — per-frame detection results
   - `masks: list[dict[str, list]] | None` — per-frame segmentation masks
   - `tracks: list[list] | None` — per-frame tracking results
   - `midline_sets: list | None` — per-frame 2D midline sets
   - `midlines_3d: list[dict] | None` — per-frame 3D midline results
   - `stage_timing: dict[str, float]` — wall-clock seconds per stage (default_factory=dict)
   Use generic list/dict types here (not domain types) to avoid importing from computation modules into engine — the import boundary demands engine/ never imports domain types at runtime. Use string annotations in docstrings to describe the actual types.
3. Add a `PipelineContext.get(field_name)` convenience method that raises `ValueError` with a clear message if the requested field is None (i.e., the producing stage hasn't run yet).

**`__init__.py`:**
- Module docstring describing the engine package
- Import and re-export `Stage`, `PipelineContext`
- Define `__all__ = ["Stage", "PipelineContext"]` (will grow as other modules are added)

**Import boundary rule (ENG-07):** The engine package must NOT import any types from `aquapose.calibration`, `aquapose.segmentation`, `aquapose.reconstruction`, `aquapose.tracking`, `aquapose.mesh`, `aquapose.initialization`, `aquapose.io`, `aquapose.visualization`, or `aquapose.synthetic` — not even under `TYPE_CHECKING`. PipelineContext fields use generic stdlib types only.
  </action>
  <verify>
    <automated>cd C:/Users/tucke/PycharmProjects/AquaPose && python -c "from aquapose.engine import Stage, PipelineContext; print('imports OK')"</automated>
  </verify>
  <done>engine/ package exists with Stage Protocol and PipelineContext dataclass. No imports from computation modules.</done>
</task>

<task type="auto">
  <name>Task 2: Write tests for Stage protocol conformance and PipelineContext behavior</name>
  <files>
    tests/unit/engine/__init__.py
    tests/unit/engine/test_stages.py
  </files>
  <action>
Create `tests/unit/engine/` package and `test_stages.py`:

**Tests to write:**

1. **`test_stage_structural_typing`** — Define a plain class (no inheritance) with a conforming `run(self, context: PipelineContext) -> PipelineContext` method. Assert `isinstance(instance, Stage)` is True. This proves structural typing works without inheritance (ENG-01 success criterion 1).

2. **`test_non_conforming_class_rejected`** — Define a class without a `run()` method (or wrong signature). Assert `isinstance(instance, Stage)` is False.

3. **`test_pipeline_context_accumulates_fields`** — Create a PipelineContext, set `detections` field, then set `tracks` field. Assert both are accessible and neither overwrites the other. This proves typed accumulation (ENG-02).

4. **`test_pipeline_context_defaults_none`** — Create a fresh PipelineContext. Assert all Optional fields are None by default.

5. **`test_pipeline_context_get_raises_on_none`** — Create a fresh PipelineContext. Call `ctx.get("detections")` and assert it raises `ValueError` with a descriptive message.

6. **`test_pipeline_context_get_returns_value`** — Set `ctx.detections = [...]`, call `ctx.get("detections")`, assert it returns the value.

7. **`test_import_boundary_no_computation_imports`** — Import `aquapose.engine.stages`, inspect its module attributes or source to verify it does NOT import from any computation module (`aquapose.calibration`, `aquapose.segmentation`, etc.). Use `inspect.getsource()` or check `sys.modules` after a fresh import.

Run with: `hatch run test tests/unit/engine/test_stages.py -x`
  </action>
  <verify>
    <automated>cd C:/Users/tucke/PycharmProjects/AquaPose && hatch run test tests/unit/engine/test_stages.py -x</automated>
  </verify>
  <done>All 7 tests pass. Stage protocol proven via structural typing. PipelineContext accumulation verified. Import boundary confirmed clean.</done>
</task>

</tasks>

<verification>
1. `from aquapose.engine import Stage, PipelineContext` succeeds
2. A class with `run(self, context) -> PipelineContext` passes `isinstance(..., Stage)` without inheriting
3. PipelineContext fields default to None and accumulate independently
4. `hatch run test tests/unit/engine/test_stages.py -x` — all tests pass
5. No imports from computation modules in `engine/stages.py`
</verification>

<success_criteria>
- Stage Protocol is defined with `@runtime_checkable` and structural typing
- PipelineContext is a typed dataclass with Optional fields and a `.get()` method
- engine/ `__init__.py` exports both with `__all__`
- 7 unit tests pass covering protocol conformance, accumulation, and import boundary
</success_criteria>

<output>
After completion, create `.planning/phases/13-engine-core/13-01-SUMMARY.md`
</output>
