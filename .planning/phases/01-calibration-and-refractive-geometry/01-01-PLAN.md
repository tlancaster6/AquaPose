---
phase: 01-calibration-and-refractive-geometry
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aquapose/calibration/__init__.py
  - src/aquapose/calibration/loader.py
  - src/aquapose/calibration/projection.py
  - tests/unit/calibration/__init__.py
  - tests/unit/calibration/test_loader.py
  - tests/unit/calibration/test_projection.py
  - tests/integration/test_calibration_cross_validation.py
  - pyproject.toml
  - CLAUDE.md
autonomous: true

must_haves:
  truths:
    - "load_calibration_data() returns CalibrationData with cameras dict, water_z, interface_normal, n_air, n_water from AquaCal JSON"
    - "RefractiveProjectionModel.project() maps 3D underwater points to 2D pixel coordinates with Newton-Raphson solver"
    - "RefractiveProjectionModel.cast_ray() maps 2D pixel coordinates to 3D underwater ray origins and directions via Snell's law"
    - "Autograd backward pass completes without error through project() and cast_ray()"
    - "torch.autograd.gradcheck passes for project() with float64 inputs"
    - "Cross-validation against AquaCal NumPy reference passes within atol=1e-5 for both project and cast_ray"
  artifacts:
    - path: "src/aquapose/calibration/loader.py"
      provides: "AquaCal bridge — load JSON into PyTorch tensors"
      contains: "load_calibration_data"
    - path: "src/aquapose/calibration/projection.py"
      provides: "Differentiable refractive projection and ray casting"
      contains: "RefractiveProjectionModel"
    - path: "src/aquapose/calibration/__init__.py"
      provides: "Public API for calibration module"
      exports: ["load_calibration_data", "CalibrationData", "CameraData", "RefractiveProjectionModel", "compute_undistortion_maps"]
    - path: "tests/integration/test_calibration_cross_validation.py"
      provides: "Cross-validation tests against AquaCal NumPy"
      contains: "test_project_cross_validation"
  key_links:
    - from: "src/aquapose/calibration/loader.py"
      to: "aquacal.io.serialization.load_calibration"
      via: "import and call"
      pattern: "from aquacal\\.io\\.serialization import"
    - from: "src/aquapose/calibration/projection.py"
      to: "src/aquapose/calibration/loader.py"
      via: "K, R, t tensors from CameraData"
      pattern: "RefractiveProjectionModel.*K.*R.*t"
    - from: "tests/integration/test_calibration_cross_validation.py"
      to: "aquacal.core.refractive_geometry"
      via: "NumPy reference comparison"
      pattern: "refractive_project|trace_ray_air_to_water"
---

<objective>
Port AquaMVS's calibration loader and refractive projection model into AquaPose, then validate numerical equivalence with AquaCal's NumPy reference implementation.

Purpose: Provides the differentiable refractive projection layer (CALIB-01, CALIB-02, CALIB-03) that all downstream phases depend on. Errors here silently corrupt every gradient in the system.

Output: Working `aquapose.calibration` module with `load_calibration_data()`, `RefractiveProjectionModel` (project + cast_ray), `compute_undistortion_maps()`, and cross-validation tests proving equivalence with AquaCal.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-calibration-and-refractive-geometry/01-RESEARCH.md

# AquaMVS reference source — port from these files
@C:/Users/tucke/PycharmProjects/AquaMVS/src/aquamvs/calibration.py
@C:/Users/tucke/PycharmProjects/AquaMVS/src/aquamvs/projection/refractive.py

# AquaMVS test patterns — follow these
@C:/Users/tucke/PycharmProjects/AquaMVS/tests/test_projection/test_cross_validation.py
@C:/Users/tucke/PycharmProjects/AquaMVS/tests/test_projection/test_refractive.py
@C:/Users/tucke/PycharmProjects/AquaMVS/tests/test_calibration.py

# AquaCal reference — for understanding API surface
@C:/Users/tucke/PycharmProjects/AquaCal/src/aquacal/io/serialization.py
@C:/Users/tucke/PycharmProjects/AquaCal/src/aquacal/core/refractive_geometry.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Port calibration loader and refractive projection model from AquaMVS</name>
  <files>
    src/aquapose/calibration/loader.py
    src/aquapose/calibration/projection.py
    src/aquapose/calibration/__init__.py
    pyproject.toml
    CLAUDE.md
  </files>
  <action>
Port AquaMVS source into AquaPose's calibration module. This is an adapt-and-port task, not a reimplementation.

**loader.py** — Port from `C:/Users/tucke/PycharmProjects/AquaMVS/src/aquamvs/calibration.py`:
- Port `CameraData` dataclass (name, K, dist_coeffs, R, t, image_size, is_fisheye, is_auxiliary)
- Port `CalibrationData` dataclass (cameras dict, water_z, interface_normal, n_air, n_water)
- Port `load_calibration_data(calibration_path)` function — loads AquaCal JSON, converts to PyTorch tensors
- Port `compute_undistortion_maps(camera)` function — dispatches on is_fisheye, returns K_new + remap tables
- Port `undistort_image(image, maps)` helper
- Key details: water_z comes from first camera (`next(iter(result.cameras.values())).water_z`), squeeze 2D arrays to 1D for t and interface_normal, dist_coeffs stay float64 (OpenCV needs it), K/R/t are float32
- Remove any AquaMVS-specific imports (e.g., logging config). Adjust imports to use `aquapose.calibration` not `aquamvs.calibration`
- Add Google-style docstrings and type hints per project conventions

**projection.py** — Port from `C:/Users/tucke/PycharmProjects/AquaMVS/src/aquamvs/projection/refractive.py`:
- Port `RefractiveProjectionModel` class verbatim
- Constructor: K, R, t (float32), water_z (float), normal (float32 tensor), n_air, n_water (float). Precomputes K_inv and C = -R^T @ t
- `project(points: Tensor) -> tuple[Tensor, Tensor]`: 3D->2D with 10 fixed Newton-Raphson iterations. Returns (pixels N×2, valid N bool). NaN for invalid. Uses `torch.clamp` and `torch.minimum` (NOT in-place) for autograd safety. Epsilon 1e-12 in sqrt.
- `cast_ray(pixels: Tensor) -> tuple[Tensor, Tensor]`: 2D->3D ray via Snell's law. Returns (origins N×3 on water surface, directions N×3 unit vectors into water).
- `to(device)` method to move all internal tensors
- Do NOT import AquaMVS — this is a copy, not a dependency

**__init__.py** — Update to export public API:
- Export: `load_calibration_data`, `CalibrationData`, `CameraData`, `RefractiveProjectionModel`, `compute_undistortion_maps`, `UndistortionMaps`
- Define `__all__` list

**pyproject.toml** — Add AquaCal prerequisite comment (same pattern as pytorch3d):
- Add comment below pytorch3d comment: `# aquacal must be installed separately (local package): pip install -e "path/to/AquaCal"`
- Do NOT add aquacal to the dependencies list (not on PyPI, path would break portability)

**CLAUDE.md** — Add aquacal install step in Quick Start section after the pytorch3d note
  </action>
  <verify>
Run: `python -c "from aquapose.calibration import load_calibration_data, CalibrationData, CameraData, RefractiveProjectionModel, compute_undistortion_maps"` — should import without error.

Run: `python -c "from aquapose.calibration.projection import RefractiveProjectionModel; import torch; m = RefractiveProjectionModel(K=torch.eye(3), R=torch.eye(3), t=torch.zeros(3), water_z=1.0, normal=torch.tensor([0.,0.,-1.]), n_air=1.0, n_water=1.333); pts = torch.tensor([[0.,0.,1.5]]); px, v = m.project(pts); print(px, v)"` — should print pixel coordinates and validity.

Run `hatch run lint` — no ruff errors on new files.
  </verify>
  <done>
loader.py contains load_calibration_data, CameraData, CalibrationData, compute_undistortion_maps ported from AquaMVS. projection.py contains RefractiveProjectionModel with project() and cast_ray() ported from AquaMVS. __init__.py exports all public symbols. pyproject.toml and CLAUDE.md document AquaCal as a prerequisite. All imports succeed and lint passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write unit and cross-validation tests for loader and projection</name>
  <files>
    tests/unit/calibration/__init__.py
    tests/unit/calibration/test_loader.py
    tests/unit/calibration/test_projection.py
    tests/integration/test_calibration_cross_validation.py
  </files>
  <action>
Write tests following AquaMVS test patterns. Tests must pass WITHOUT a real AquaCal calibration JSON file (use synthetic fixtures for unit tests). Cross-validation tests against AquaCal NumPy DO require aquacal installed.

**tests/unit/calibration/__init__.py** — Empty init file.

**tests/unit/calibration/test_loader.py** — Port test patterns from `C:/Users/tucke/PycharmProjects/AquaMVS/tests/test_calibration.py`:
- Mock `aquacal.io.serialization.load_calibration` to return synthetic calibration data
- Test load_calibration_data returns CalibrationData with correct types (K is float32 3×3, R is float32 3×3, t is float32 1D length-3, dist_coeffs is float64, etc.)
- Test water_z is extracted correctly (from first camera)
- Test interface_normal is squeezed to 1D
- Test all 13 cameras are loaded (if mocking a 13-camera rig fixture)
- Test is_fisheye flag is preserved

**tests/unit/calibration/test_projection.py** — Port test patterns from `C:/Users/tucke/PycharmProjects/AquaMVS/tests/test_projection/test_refractive.py`:
- Use synthetic reference geometry: camera at (0.635, 0, 0), R=eye(3), t=(-0.635, 0, 0), K with fx=fy=1400, cx=800, cy=600, water_z=0.978, normal=(0,0,-1), n_air=1.0, n_water=1.333, no distortion
- Test project() returns valid pixels for underwater points (Z > water_z)
- Test project() returns invalid for points above water (Z < water_z)
- Test cast_ray() returns origins on water surface (Z = water_z)
- Test cast_ray() returns unit direction vectors
- Test cast_ray() directions obey Snell's law at the interface
- Test project/cast_ray roundtrip: project a point, cast_ray the resulting pixel, verify the ray passes through (near) the original point
- Test autograd backward: project() with requires_grad=True points, call .backward(), verify .grad is finite and non-zero
- Test torch.autograd.gradcheck: convert model and inputs to float64, run gradcheck with atol=1e-4, rtol=1e-3
- Test to(device) method moves tensors (test with CPU, skip if no GPU)
- Test batch processing: project N points at once, cast_ray N pixels at once

**tests/integration/test_calibration_cross_validation.py** — Port from `C:/Users/tucke/PycharmProjects/AquaMVS/tests/test_projection/test_cross_validation.py`:
- Mark all tests with `@pytest.mark.slow` (requires aquacal installed)
- Use same synthetic reference geometry as unit tests
- Build AquaCal Camera + Interface objects from the same parameters
- For project cross-validation: call aquacal's `refractive_project` for each point, call AquaPose's `model.project()` for batch, assert `torch.allclose(atol=1e-5)` per point
- For cast_ray cross-validation: call aquacal's `trace_ray_air_to_water` for each pixel, call AquaPose's `model.cast_ray()` for batch, assert `torch.allclose(atol=1e-5)` for origins and directions
- Test at multiple depths: water_z+0.1, water_z+0.3, water_z+0.5 (shallow, mid, deep)
- Test at multiple XY positions including off-center points

Tolerance: atol=1e-5 for cross-validation (float32 vs float64 boundary). This matches AquaMVS's own tolerance.
  </action>
  <verify>
Run: `hatch run test tests/unit/calibration/` — all unit tests pass.

Run: `hatch run test-all tests/integration/test_calibration_cross_validation.py` — cross-validation tests pass (requires aquacal installed).

Run: `hatch run lint tests/` — no ruff errors.
  </verify>
  <done>
Unit tests verify: correct tensor types/shapes from loader, projection outputs valid pixels, ray casting produces surface origins with unit directions obeying Snell's law, project/cast_ray roundtrip consistency, autograd backward completes with finite gradients, gradcheck passes in float64. Cross-validation tests verify numerical equivalence with AquaCal NumPy within atol=1e-5 for both project and cast_ray at multiple depths and positions. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from aquapose.calibration import load_calibration_data, RefractiveProjectionModel"` — imports succeed
2. `hatch run test tests/unit/calibration/` — unit tests pass
3. `hatch run test-all tests/integration/test_calibration_cross_validation.py` — cross-validation passes
4. `hatch run lint` — no lint errors on new/modified files
5. Manual spot check: `RefractiveProjectionModel` constructor, project(), and cast_ray() match AquaMVS source logic
</verification>

<success_criteria>
- CalibrationData loads from AquaCal JSON with all cameras, correct tensor types, and water surface parameters
- RefractiveProjectionModel.project() produces pixel coordinates for underwater points using 10-iteration Newton-Raphson
- RefractiveProjectionModel.cast_ray() produces ray origins on water surface and refracted unit direction vectors
- Gradients flow through both project() and cast_ray() — backward() completes, gradcheck passes
- Cross-validation against AquaCal NumPy passes within atol=1e-5 for project and cast_ray
</success_criteria>

<output>
After completion, create `.planning/phases/01-calibration-and-refractive-geometry/01-01-SUMMARY.md`
</output>
