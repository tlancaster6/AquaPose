---
phase: 15-stage-migrations
plan: 03
type: execute
wave: 3
depends_on: [15-02]
files_modified:
  - src/aquapose/core/association/__init__.py
  - src/aquapose/core/association/types.py
  - src/aquapose/core/association/backends/__init__.py
  - src/aquapose/core/association/backends/ransac_centroid.py
  - src/aquapose/core/association/stage.py
  - src/aquapose/engine/config.py
  - src/aquapose/engine/stages.py
  - tests/unit/core/association/__init__.py
  - tests/unit/core/association/test_association_stage.py
autonomous: true
requirements: [STG-03]

must_haves:
  truths:
    - AssociationStage satisfies engine.stages.Stage protocol via structural typing
    - AssociationStage.run(context) reads context.detections (or annotated_detections) and produces context.associated_bundles
    - RANSAC centroid clustering backend groups detections across cameras into per-fish bundles
    - Each bundle contains camera_id->detection_index mappings and a triangulated 3D centroid
    - No imports from engine/ in any core/association/ module
  artifacts:
    - src/aquapose/core/association/__init__.py
    - src/aquapose/core/association/types.py
    - src/aquapose/core/association/stage.py
    - src/aquapose/core/association/backends/ransac_centroid.py
    - tests/unit/core/association/test_association_stage.py
  key_links:
    - AssociationStage reads PipelineContext.detections and PipelineContext.annotated_detections (from Stages 1-2)
    - AssociationStage writes PipelineContext.associated_bundles
    - Uses existing aquapose.tracking.associate module (RANSAC centroid logic)
    - Uses calibration models for ray casting and triangulation
---

<objective>
Port the Cross-View Association stage (Stage 3) as a pure Stage Protocol implementor in core/association/.

Purpose: Association matches fish detections across cameras into cross-view bundles. In v1.0, this was embedded inside the tracker (FishTracker.update() calls discover_births() for new fish and claim_detections_for_tracks() for existing fish). In the new model, Association is extracted as a distinct stage that groups ALL detections per frame into bundles, independent of tracking state.

This is the most architecturally novel stage — it extracts logic that was previously interleaved with tracking. The v1.0 `discover_births()` function in `tracking/associate.py` provides the core RANSAC centroid clustering algorithm.

Output: An AssociationStage class in core/association/ that reads detections and produces associated_bundles per frame.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-stage-migrations/15-CONTEXT.md

@src/aquapose/engine/stages.py
@src/aquapose/engine/config.py
@src/aquapose/tracking/associate.py (v1.0 RANSAC centroid clustering — core algorithm to port)
@src/aquapose/tracking/tracker.py (v1.0 tracker — shows how association was embedded in tracking)
@src/aquapose/calibration/projection.py (RefractiveProjectionModel, triangulate_rays)
@src/aquapose/segmentation/detector.py (Detection dataclass)
@src/aquapose/pipeline/orchestrator.py (calibration/model loading pattern)

<interfaces>
<!-- Engine contracts -->
From src/aquapose/engine/stages.py:
```python
@dataclass
class PipelineContext:
    detections: list[dict[str, list]] | None = None
    annotated_detections: list[dict[str, list]] | None = None
    associated_bundles: list[list] | None = None  # Stage 3 writes this
    camera_ids: list[str] | None = None
```

From src/aquapose/engine/config.py:
```python
@dataclass(frozen=True)
class AssociationConfig:
    pass  # Empty placeholder — to be extended here
```

<!-- Core algorithm from v1.0 -->
From src/aquapose/tracking/associate.py:
```python
@dataclass
class AssociationResult:
    fish_id: int
    centroid_3d: np.ndarray  # shape (3,)
    reprojection_residual: float
    camera_detections: dict[str, int]  # camera_id -> detection_index
    n_cameras: int
    confidence: float

def discover_births(
    unclaimed_indices: dict[str, list[int]],
    detections_per_camera: dict[str, list[Detection]],
    models: dict[str, RefractiveProjectionModel],
    expected_count: int = 9,
    reprojection_threshold: float = 15.0,
    min_cameras: int = 3,
    seed_points: list[np.ndarray] | None = None,
    near_claim_distances: dict[str, dict[int, float]] | None = None,
) -> list[AssociationResult]: ...
```

This function does RANSAC centroid clustering on unclaimed detections. In the new Association stage, ALL detections in a frame are "unclaimed" (there are no tracks yet at this point). The function returns a list of AssociationResult bundles, each representing one physical fish.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create core/association/ module with RANSAC backend and stage</name>
  <files>
    src/aquapose/core/association/__init__.py
    src/aquapose/core/association/types.py
    src/aquapose/core/association/backends/__init__.py
    src/aquapose/core/association/backends/ransac_centroid.py
    src/aquapose/core/association/stage.py
    src/aquapose/engine/config.py
    src/aquapose/engine/stages.py
  </files>
  <action>
Create the core/association/ package:

1. **types.py** — Define `AssociationBundle` dataclass for the stage output:
   ```python
   @dataclass
   class AssociationBundle:
       fish_idx: int  # 0-indexed within this frame (not persistent ID)
       centroid_3d: np.ndarray  # shape (3,), world coordinates
       camera_detections: dict[str, int]  # camera_id -> detection_index
       n_cameras: int
       reprojection_residual: float
       confidence: float
   ```
   This is essentially AssociationResult with fish_idx instead of fish_id (fish_id is assigned by Tracking, not Association).

2. **backends/__init__.py** — Backend registry. `get_backend(kind: str, **kwargs)` factory. Only "ransac_centroid" supported. Raise ValueError for unknown.

3. **backends/ransac_centroid.py** — RANSAC centroid clustering backend:
   - Constructor accepts `calibration_path`, `expected_count`, `min_cameras`, `reprojection_threshold`, `skip_camera_id`, plus any other parameters from the existing discover_births function
   - Loads calibration data and builds RefractiveProjectionModel per camera at construction (eager, fail-fast)
   - Exposes `associate_frame(detections_per_camera: dict[str, list[Detection]]) -> list[AssociationBundle]`:
     - All detections are "unclaimed" (no prior tracks at this stage)
     - Builds unclaimed_indices as {cam: list(range(len(dets)))} for all cameras
     - Calls existing `discover_births()` from `aquapose.tracking.associate`
     - Converts AssociationResult objects to AssociationBundle objects
     - Returns list of bundles for this frame

   Port behavior exactly from v1.0. The existing `discover_births()` function IS the RANSAC centroid clustering algorithm. Delegate to it directly rather than reimplementing.

4. **stage.py** — `AssociationStage` class satisfying Stage Protocol:
   - Constructor: accepts `calibration_path: str | Path`, `expected_count: int = 9`, `min_cameras: int = 3`, `reprojection_threshold: float = 15.0`, `skip_camera_id: str = "e3v8250"`, `backend: str = "ransac_centroid"`
   - Creates the selected backend at construction
   - `run(self, context)`:
     - Reads context.detections (list of per-frame per-camera detection dicts)
     - For each frame, calls backend.associate_frame() to produce bundles
     - Sets context.associated_bundles = list of per-frame bundle lists
     - Returns context

   CRITICAL: core/association/ must NOT import from engine/. TYPE_CHECKING guard for PipelineContext.

5. **__init__.py** — Export AssociationStage, AssociationBundle.

6. **engine/config.py** — Extend AssociationConfig with fields:
   ```python
   @dataclass(frozen=True)
   class AssociationConfig:
       expected_count: int = 9
       min_cameras: int = 3
       reprojection_threshold: float = 15.0
   ```

7. **engine/stages.py** — Update PipelineContext.associated_bundles docstring to reference AssociationBundle type.

Record any v1.0 quirks in the bug ledger. Key consideration: in v1.0, discover_births was called only for unclaimed detections (after track claiming). In the new model, ALL detections are passed to association. The resulting bundles will be input to Tracking (Stage 4) which then does the temporal association.
  </action>
  <verify>
    <automated>hatch run python -c "from aquapose.core.association import AssociationStage, AssociationBundle; print('imports OK')"</automated>
  </verify>
  <done>
    - AssociationStage exists in core/association/stage.py
    - RANSAC centroid backend delegates to existing discover_births()
    - run() reads context.detections and populates context.associated_bundles
    - AssociationBundle type clearly defines per-fish cross-camera groupings
    - No imports from engine/ in core/association/
  </done>
</task>

<task type="auto">
  <name>Task 2: Interface tests for AssociationStage</name>
  <files>
    tests/unit/core/association/__init__.py
    tests/unit/core/association/test_association_stage.py
  </files>
  <action>
Create interface tests:

1. **test_association_stage_satisfies_protocol** — Assert isinstance(stage, Stage) passes.

2. **test_association_stage_populates_bundles** — Create stage with mocked calibration/models. Feed a PipelineContext with synthetic detections (mock detections in 3+ cameras). Assert context.associated_bundles is populated as a list of per-frame lists.

3. **test_association_bundle_structure** — Verify AssociationBundle has correct fields: fish_idx, centroid_3d, camera_detections, n_cameras, reprojection_residual, confidence.

4. **test_backend_registry_unknown_raises** — Assert ValueError for unknown backend kind.

5. **test_import_boundary** — Inspect source of all modules in core/association/ and assert no imports from aquapose.engine.

6. **test_empty_detections_produces_empty_bundles** — Feed a frame with no detections, assert empty bundle list.

For tests needing calibration models, mock the RefractiveProjectionModel and discover_births function. Focus on verifying the stage wiring and data flow contract.
  </action>
  <verify>
    <automated>hatch run test tests/unit/core/association/test_association_stage.py -x -v</automated>
  </verify>
  <done>
    - All tests pass
    - AssociationStage confirmed to satisfy Stage Protocol
    - Bundle structure validated
    - Import boundary verified
  </done>
</task>

</tasks>

<verification>
1. `isinstance(AssociationStage(...), Stage)` returns True
2. `hatch run test tests/unit/core/association/ -v` — all pass
3. `hatch run check` — no lint or type errors
4. grep for "engine" in src/aquapose/core/association/ returns nothing
</verification>

<success_criteria>
- AssociationStage satisfies Stage Protocol via structural typing
- RANSAC backend delegates to existing discover_births() algorithm
- run() produces context.associated_bundles from context.detections
- Interface tests pass
- No engine/ imports in core/association/
</success_criteria>

<output>
After completion, create `.planning/phases/15-stage-migrations/15-03-SUMMARY.md`
</output>
