---
phase: 05-cross-view-identity-and-3d-tracking
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - src/aquapose/tracking/writer.py
  - src/aquapose/tracking/__init__.py
  - tests/unit/tracking/test_writer.py
autonomous: true
requirements:
  - TRACK-01
  - TRACK-02
  - TRACK-03
  - TRACK-04

must_haves:
  truths:
    - "HDF5 writer serializes tracking results with chunked resizable datasets for hours-long videos"
    - "Per-fish per-frame data includes 3D centroid, confidence, reprojection residual, n_cameras, camera assignments, and per-camera bboxes"
    - "Writer buffers frames in memory and flushes full chunks for write performance"
    - "Tracking module exposes a clean end-to-end API: detections in → tracklets with HDF5 output"
    - "Round-trip test confirms data written to HDF5 matches data read back"
  artifacts:
    - path: "src/aquapose/tracking/writer.py"
      provides: "HDF5 serialization of tracking results"
      exports: ["TrackingWriter"]
    - path: "src/aquapose/tracking/__init__.py"
      provides: "Complete public API for tracking module"
      exports: ["ransac_centroid_cluster", "AssociationResult", "FrameAssociations", "FishTrack", "FishTracker", "TrackingWriter"]
    - path: "tests/unit/tracking/test_writer.py"
      provides: "HDF5 write/read round-trip tests"
  key_links:
    - from: "src/aquapose/tracking/writer.py"
      to: "src/aquapose/tracking/tracker.py"
      via: "consumes FishTracker.get_all_tracks() output"
      pattern: "from .tracker import"
    - from: "src/aquapose/tracking/writer.py"
      to: "h5py"
      via: "chunked resizable HDF5 datasets"
      pattern: "import h5py"
---

<objective>
Implement HDF5 serialization for tracking results and finalize the tracking module's public API.

Purpose: This plan delivers the output interface — the serialization layer that stores tracking results in a chunked HDF5 format suitable for hours-long videos, plus the wiring that makes the full tracking pipeline accessible as a single coherent module. Downstream phases (Phase 6: medial axis) will consume this HDF5 output to get per-fish camera sets and bounding boxes.

Output: `src/aquapose/tracking/writer.py` with `TrackingWriter` class, finalized `__init__.py`, and round-trip tests.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-cross-view-identity-and-3d-tracking/05-CONTEXT.md
@.planning/phases/05-cross-view-identity-and-3d-tracking/05-RESEARCH.md
@.planning/phases/05-cross-view-identity-and-3d-tracking/05-01-SUMMARY.md
@.planning/phases/05-cross-view-identity-and-3d-tracking/05-02-SUMMARY.md

@src/aquapose/tracking/__init__.py
@src/aquapose/tracking/associate.py
@src/aquapose/tracking/tracker.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement HDF5 tracking writer with chunked datasets</name>
  <files>
    src/aquapose/tracking/writer.py
    src/aquapose/tracking/__init__.py
  </files>
  <action>
**`writer.py`** — HDF5 serialization for tracking output:

1. **`TrackingWriter` class**:
   - Constructor: `__init__(self, output_path: str | Path, camera_names: list[str], max_fish: int = 9, chunk_frames: int = 1000)`
   - Creates HDF5 file with `/tracking/` group and these datasets (all with `maxshape=(None, ...)`, `chunks=(chunk_frames, ...)`, gzip compression level 4):
     - `frame_index`: shape `(0,)`, dtype int64
     - `fish_id`: shape `(0, max_fish)`, dtype int32, fillvalue=-1
     - `centroid_3d`: shape `(0, max_fish, 3)`, dtype float32, fillvalue=NaN
     - `confidence`: shape `(0, max_fish)`, dtype float32, fillvalue=-1.0
     - `reprojection_residual`: shape `(0, max_fish)`, dtype float32, fillvalue=-1.0
     - `n_cameras`: shape `(0, max_fish)`, dtype int32, fillvalue=0
     - `is_confirmed`: shape `(0, max_fish)`, dtype bool, fillvalue=False
     - `/tracking/camera_assignments/{camera_name}`: shape `(0, max_fish)`, dtype int32, fillvalue=-1 — detection index per camera per fish
     - `/tracking/bboxes/{camera_name}`: shape `(0, max_fish, 4)`, dtype int32, fillvalue=-1 — (x, y, w, h)
   - Store `camera_names` as an attribute on the `/tracking` group for self-documentation.

2. **Buffer and flush pattern**:
   - `self._buffer`: dict of numpy arrays, one per dataset field, pre-allocated to `chunk_frames` size
   - `self._buffer_idx: int = 0` — current position in buffer
   - `write_frame(frame_index: int, tracks: list[FishTrack]) -> None`:
     - Fill buffer row `self._buffer_idx` from track data. For each track, write fish_id, centroid_3d (from `track.positions[-1]`), confidence, reprojection_residual, n_cameras, is_confirmed, camera_detections (mapping to detection index per camera), bboxes. Fish slot in the row = position in sorted tracks list (sorted by fish_id for deterministic ordering). Absent fish slots stay at fillvalue.
     - Increment `self._buffer_idx`. If `self._buffer_idx == chunk_frames`, call `_flush()`.
   - `_flush() -> None`: resize all HDF5 datasets by `self._buffer_idx` rows on axis 0, write buffer slice `[:self._buffer_idx]`, reset `self._buffer_idx = 0`.
   - `close() -> None`: flush remaining buffer, close HDF5 file.
   - Context manager support: `__enter__` / `__exit__` with `close()` in `__exit__`.

3. **`read_tracking_results(path: str | Path) -> dict`** — standalone function:
   - Opens HDF5 file, reads all datasets into numpy arrays, returns dict with keys matching dataset names. Also reads camera_names attribute.
   - This is a convenience reader for downstream consumers (Phase 6) and for testing round-trips.

**Update `__init__.py`**: Add `TrackingWriter`, `read_tracking_results` to imports and `__all__`. Final `__all__` should include all public symbols from all 3 plans:
```python
__all__ = [
    "AssociationResult", "FrameAssociations", "ransac_centroid_cluster",
    "FishTrack", "FishTracker",
    "TrackingWriter", "read_tracking_results",
]
```
  </action>
  <verify>
    `hatch run check` passes. `python -c "from aquapose.tracking import TrackingWriter, read_tracking_results"` succeeds.
  </verify>
  <done>
    `TrackingWriter` creates chunked HDF5 with all required datasets, buffers writes for performance, supports context manager. `read_tracking_results` provides round-trip reading. All 8 public symbols exported from `aquapose.tracking`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for HDF5 writer round-trip and integration smoke test</name>
  <files>
    tests/unit/tracking/test_writer.py
  </files>
  <action>
**Test cases** (all use `tmp_path` fixture, no real data):

1. **`test_write_read_roundtrip`**: Create `TrackingWriter`, write 5 frames with 3 synthetic `FishTrack` objects each (varying positions). Close writer. Read back with `read_tracking_results()`. Assert: all fields match — fish_id, centroid_3d, confidence, n_cameras, is_confirmed. Shapes are `(5, max_fish, ...)`.

2. **`test_chunked_flush`**: Set `chunk_frames=3`. Write 7 frames. Assert: after 3 frames, first chunk is flushed to disk (HDF5 dataset shape grows). After close, all 7 frames present.

3. **`test_context_manager`**: Use `with TrackingWriter(...) as w:` pattern. Write frames. Assert: file is properly closed and readable after `with` block exits.

4. **`test_camera_assignments_and_bboxes`**: Write frames with camera_detections and bboxes populated. Read back. Assert: per-camera assignment indices and bbox coordinates match for each fish in each frame. Absent fish have -1 fillvalues.

5. **`test_absent_fish_fillvalues`**: Write a frame where only 2 of 9 fish slots are populated. Read back. Assert: fish slots 2-8 have fish_id=-1, centroid_3d=NaN, confidence=-1.0, n_cameras=0.

6. **`test_camera_names_attribute`**: Write and read. Assert: `camera_names` attribute on `/tracking` group matches the list passed to constructor.

7. **`test_empty_file`**: Create writer, close immediately without writing. Assert: file exists, datasets have shape `(0, ...)`, readable without error.

8. **`test_integration_tracker_to_writer`**: Create a `FishTracker`, feed it 3 frames of synthetic `FrameAssociations`, pass resulting tracks to `TrackingWriter.write_frame()`. Read back. Assert: fish IDs in HDF5 match tracker's assigned IDs, centroids are non-NaN for confirmed tracks.

All tests use `pytest`'s `tmp_path` for file cleanup. No `@slow` marks.
  </action>
  <verify>
    `hatch run test tests/unit/tracking/test_writer.py` — all tests pass.
    `hatch run test tests/unit/tracking/` — all tracking tests pass (Plans 01 + 02 + 03).
  </verify>
  <done>
    8 unit tests covering: round-trip correctness, chunked flushing, context manager, camera assignments/bboxes, fillvalues, camera_names attribute, empty file, and tracker→writer integration. All pass.
  </done>
</task>

</tasks>

<verification>
- `hatch run check` passes (lint + typecheck)
- `hatch run test tests/unit/tracking/` — all tests pass (all 3 plans)
- HDF5 output matches the schema from RESEARCH.md (columnar layout, chunked, gzip)
- Round-trip: write → read produces identical data
- Full public API exported from `aquapose.tracking`
</verification>

<success_criteria>
- HDF5 writer creates properly chunked datasets for all required fields
- Per-camera bounding boxes are stored per-fish per-frame (for Phase 6 consumption)
- Buffer-and-flush pattern avoids per-frame I/O overhead
- Round-trip tests confirm data integrity
- Integration test proves tracker output flows cleanly into writer
- Complete tracking module API importable: `from aquapose.tracking import FishTracker, TrackingWriter, ransac_centroid_cluster`
</success_criteria>

<output>
After completion, create `.planning/phases/05-cross-view-identity-and-3d-tracking/05-03-SUMMARY.md`
</output>
