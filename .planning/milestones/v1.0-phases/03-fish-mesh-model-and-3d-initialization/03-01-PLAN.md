---
phase: 03-fish-mesh-model-and-3d-initialization
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/aquapose/mesh/__init__.py
  - src/aquapose/mesh/state.py
  - src/aquapose/mesh/profiles.py
  - src/aquapose/mesh/spine.py
  - src/aquapose/mesh/cross_section.py
  - src/aquapose/mesh/builder.py
  - tests/unit/mesh/__init__.py
  - tests/unit/mesh/test_state.py
  - tests/unit/mesh/test_spine.py
  - tests/unit/mesh/test_cross_section.py
  - tests/unit/mesh/test_builder.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "Given a FishState {p, psi, theta, kappa, s}, build_fish_mesh returns a watertight triangle mesh"
    - "Gradients flow from mesh vertices back through all 5 state parameters (p, psi, theta, kappa, s)"
    - "Near-zero curvature (kappa ~= 0) produces finite vertices and finite gradients (no NaN)"
    - "Free cross-section mode allows per-section height and width to be optimizable parameters with gradient flow"
    - "Batch API: build_fish_mesh accepts list[FishState] and returns a Meshes batch"
  artifacts:
    - path: "src/aquapose/mesh/state.py"
      provides: "FishState dataclass with 5 tensor fields"
      contains: "class FishState"
    - path: "src/aquapose/mesh/spine.py"
      provides: "Circular arc spine generation with stable kappa~=0 handling"
      exports: ["build_spine_frames"]
    - path: "src/aquapose/mesh/cross_section.py"
      provides: "Elliptical cross-section vertex generation"
      exports: ["build_cross_section_verts"]
    - path: "src/aquapose/mesh/builder.py"
      provides: "Mesh assembly and PyTorch3D Meshes wrapping"
      exports: ["build_fish_mesh"]
    - path: "src/aquapose/mesh/profiles.py"
      provides: "Default cichlid profile and CrossSectionProfile dataclass"
      exports: ["DEFAULT_CICHLID_PROFILE"]
  key_links:
    - from: "src/aquapose/mesh/builder.py"
      to: "src/aquapose/mesh/spine.py"
      via: "build_spine_frames call"
      pattern: "build_spine_frames"
    - from: "src/aquapose/mesh/builder.py"
      to: "src/aquapose/mesh/cross_section.py"
      via: "build_cross_section_verts call"
      pattern: "build_cross_section_verts"
    - from: "src/aquapose/mesh/builder.py"
      to: "pytorch3d.structures.Meshes"
      via: "wrapping verts/faces into Meshes"
      pattern: "Meshes\\(verts="
---

<objective>
Build the differentiable parametric fish mesh model: FishState dataclass, circular arc spine, elliptical cross-sections, and mesh assembly wrapped in PyTorch3D Meshes. Covers MESH-01 (parametric mesh from state vector) and MESH-02 (free cross-section mode).

Purpose: The mesh is the core geometric primitive for the entire analysis-by-synthesis pipeline. Every downstream phase (rendering, optimization, tracking) depends on being able to differentiate through mesh vertex positions with respect to the fish state vector.

Output: Working `build_fish_mesh(states: list[FishState]) -> Meshes` with full gradient flow and tests.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-fish-mesh-model-and-3d-initialization/03-CONTEXT.md
@.planning/phases/03-fish-mesh-model-and-3d-initialization/03-RESEARCH.md
@src/aquapose/mesh/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: FishState, profiles, spine, and cross-section modules with tests</name>
  <files>
    src/aquapose/mesh/state.py
    src/aquapose/mesh/profiles.py
    src/aquapose/mesh/spine.py
    src/aquapose/mesh/cross_section.py
    tests/unit/mesh/__init__.py
    tests/unit/mesh/test_state.py
    tests/unit/mesh/test_spine.py
    tests/unit/mesh/test_cross_section.py
  </files>
  <action>
    **TDD: Write tests first, then implement.**

    **state.py — FishState dataclass:**
    - Plain Python `@dataclass` (not `nn.Module`) with 5 tensor fields: `p` (3,), `psi` (), `theta` (), `kappa` (), `s` ()
    - All fields are `torch.Tensor`
    - Add a docstring documenting each field's shape and semantics (see RESEARCH.md Pattern 1)
    - Tests: construction, field types, shapes

    **profiles.py — CrossSectionProfile and DEFAULT_CICHLID_PROFILE:**
    - Define a `CrossSectionProfile` dataclass or TypedDict with:
      - `section_positions`: list of floats in [0, 1] — fractional positions along spine
      - `heights`: list of floats — height/body_length ratios per section
      - `widths`: list of floats — width/body_length ratios per section
    - `DEFAULT_CICHLID_PROFILE`: 7 sections at `[0.0, 0.1, 0.25, 0.50, 0.75, 0.90, 1.0]` (denser at head/tail per RESEARCH open question 2). Heights/widths should follow cichlid proportions: tapered head, widest at ~40%, narrow caudal peduncle (see RESEARCH Code Examples for reference values, adjust to 7 sections)
    - Tests: section count within 5-8, positions sorted ascending, positions start at 0 and end at 1, heights/widths all positive

    **spine.py — build_spine_frames:**
    ```python
    def build_spine_frames(
        psi: torch.Tensor,    # yaw
        theta: torch.Tensor,  # pitch
        kappa: torch.Tensor,  # curvature
        s: torch.Tensor,      # scale
        section_positions: list[float],  # fractions along [0,1]
    ) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor]:
        """Generate spine center points and local coordinate frames.

        Returns:
            centers: (N, 3) — 3D positions of cross-section centers (relative to fish center, before translation by p)
            tangents: (N, 3) — unit tangent vectors along spine at each section
            normals: (N, 3) — unit normal vectors (dorsoventral direction)
            binormals: (N, 3) — unit binormal vectors (lateral direction)
        """
    ```
    - Heading vector from yaw + pitch: `[cos(psi)*cos(theta), sin(psi)*cos(theta), sin(theta)]`
    - Dorsal vector via Gram-Schmidt from heading and world-up `[0, 0, 1]`. Use `[1, 0, 0]` fallback when `|heading · [0,0,1]| > 0.99` (Pitfall 4 from RESEARCH)
    - Circular arc formula with STABLE kappa~=0 handling (Pitfall 3): use `sin(kappa*t*s) / (kappa + eps)` and `(1 - cos(kappa*t*s)) / (kappa + eps)` with eps=1e-8. This is smooth everywhere including kappa=0 where it reduces to `t*s` and `0` respectively
    - Arc positions relative to fish center (not world position p) — translation by p happens in the builder
    - Center the spine so that the midpoint (t=0.5) is at origin (the builder will translate by p)
    - All operations must be differentiable PyTorch ops — no `.numpy()`, `.item()`, or `.detach()`
    - Tests:
      - Straight fish (kappa=0): centers lie along heading direction, evenly spaced by section_positions * s
      - Curved fish (kappa=5): centers trace a circular arc, verify radius ~= 1/kappa
      - Tangent vectors are unit length
      - Gradient flows through all inputs (psi, theta, kappa, s)
      - Near-zero kappa (1e-6) produces finite outputs (no NaN)

    **cross_section.py — build_cross_section_verts:**
    ```python
    def build_cross_section_verts(
        centers: torch.Tensor,     # (N, 3)
        normals: torch.Tensor,     # (N, 3)
        binormals: torch.Tensor,   # (N, 3)
        heights: torch.Tensor,     # (N,) — may require_grad for free mode
        widths: torch.Tensor,      # (N,) — may require_grad for free mode
        s: torch.Tensor,           # scale factor
        n_verts: int = 10,         # vertices per ellipse
    ) -> torch.Tensor:
        """Generate elliptical cross-section vertices in world frame.

        Returns:
            verts: (N, M, 3) — M vertices per section, N sections.
                Heights/widths are multiplied by s to convert from unit-template
                proportions to world-frame dimensions.
        """
    ```
    - M vertices at angles `linspace(0, 2*pi, M+1)[:-1]`
    - Ellipse in local frame: `width * cos(angle) * binormal + height * sin(angle) * normal`
    - Heights and widths multiplied by scale `s` to convert from body-fraction to meters
    - Tests:
      - Section with h=w produces circular cross-section (all verts equidistant from center)
      - Section with h != w produces ellipse with correct aspect ratio
      - Left-right symmetry about normal plane
      - Gradient flows through heights, widths, s (free cross-section mode)
      - 10 vertices per section by default
  </action>
  <verify>
    `hatch run test tests/unit/mesh/test_state.py tests/unit/mesh/test_spine.py tests/unit/mesh/test_cross_section.py` — all pass.
    `hatch run typecheck` — no new errors in mesh modules.
  </verify>
  <done>
    FishState constructed from 5 tensors; spine produces N centers+frames with stable kappa handling; cross-sections produce M vertices per section with gradient flow through heights/widths/s. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Mesh builder, PyTorch3D Meshes wrapping, and integration tests</name>
  <files>
    src/aquapose/mesh/builder.py
    src/aquapose/mesh/__init__.py
    tests/unit/mesh/test_builder.py
    pyproject.toml
  </files>
  <action>
    **TDD: Write tests first, then implement.**

    **PyTorch3D installation (prerequisite):**
    - First attempt: `pip install --extra-index-url https://miropsota.github.io/torch_packages_builder pytorch3d` (let pip resolve the best version)
    - If that fails: `FORCE_CUDA=0 pip install "git+https://github.com/facebookresearch/pytorch3d.git"` (CPU-only source build)
    - Install fvcore and iopath as prerequisites if needed: `pip install fvcore iopath`
    - Verify with `python -c "from pytorch3d.structures import Meshes; print('OK')"`
    - Add pytorch3d to pyproject.toml optional dependencies (not main deps since it can't be pip-installed normally): add a `[project.optional-dependencies]` section with `pytorch3d` entry, or document installation in a comment
    - If installation completely fails, create a minimal stub `Meshes`-like class that stores verts_list/faces_list so the rest of Phase 3 can proceed, and document the issue for Phase 4

    **builder.py — build_fish_mesh and _build_faces:**
    ```python
    N_SECTIONS: int  # from len(profile.section_positions)
    M_VERTS: int = 10  # vertices per ellipse

    def build_fish_mesh(
        states: list[FishState],
        profile: CrossSectionProfile | None = None,
        heights: torch.Tensor | None = None,  # (N,) override for free cross-section mode
        widths: torch.Tensor | None = None,    # (N,) override for free cross-section mode
        n_verts: int = 10,
    ) -> Meshes:
    ```
    - For each FishState in the batch:
      1. Call `build_spine_frames(psi, theta, kappa, s, profile.section_positions)` → centers, tangents, normals, binormals
      2. Translate centers by `state.p` (add position offset)
      3. Use heights/widths from profile (as tensors) or from explicit `heights`/`widths` params for free mode. When using profile values, convert to tensors with `requires_grad=False`. When using explicit params, they may have `requires_grad=True`
      4. Call `build_cross_section_verts(centers, normals, binormals, heights_t, widths_t, s, n_verts)` → (N, M, 3)
      5. Add head apex (first section center - small offset along tangent) and tail apex (last section center + small offset along tangent)
      6. Reshape to (V, 3) where V = N*M + 2 (tube verts + 2 apex verts)
    - `_build_faces(n_sections, verts_per_section) -> torch.LongTensor`: Precompute once, reuse across batch. Tube body (2*(N-1)*M triangles) + head fan (M triangles) + tail fan (M triangles). See RESEARCH Pattern 4 for algorithm. Ensure consistent winding order (all faces CCW when viewed from outside)
    - Wrap in `Meshes(verts=verts_list, faces=faces_list)` from pytorch3d.structures
    - Return the Meshes object

    **Free cross-section mode (MESH-02):**
    - When `heights` and `widths` tensors are passed to `build_fish_mesh`, use them instead of profile values
    - These tensors may have `requires_grad=True` — gradient flows through them into the mesh vertices
    - The profile still provides section_positions (spacing along spine)

    **__init__.py — public API:**
    - Export: `FishState`, `CrossSectionProfile`, `DEFAULT_CICHLID_PROFILE`, `build_fish_mesh`, `build_spine_frames`, `build_cross_section_verts`
    - Update `__all__`

    **Tests (test_builder.py):**
    - `test_build_fish_mesh_returns_meshes`: single FishState → returns Meshes with 1 mesh, correct vertex count (N*M + 2), correct face count
    - `test_watertight_mesh`: all edges shared by exactly 2 faces (closed manifold) — implement edge counting check
    - `test_gradients_flow_through_position`: `state.p.grad is not None` after backward through `verts.sum()`
    - `test_gradients_flow_through_psi`: same for yaw angle
    - `test_gradients_flow_through_theta`: same for pitch angle
    - `test_gradients_flow_through_kappa`: same for curvature (test with both kappa=0.5 and kappa=1e-6)
    - `test_gradients_flow_through_scale`: same for scale
    - `test_free_cross_section_gradients`: pass heights/widths as requires_grad=True tensors, verify `.grad is not None` after backward
    - `test_batch_build`: list of 3 FishStates → Meshes with 3 meshes, each with correct vertex/face counts
    - `test_zero_curvature_no_nan`: kappa=0.0 exactly → no NaN in verts or grads
  </action>
  <verify>
    `hatch run test tests/unit/mesh/` — all mesh tests pass.
    `hatch run check` — lint + typecheck clean.
    `python -c "from aquapose.mesh import build_fish_mesh, FishState; print('Public API OK')"` — import succeeds.
  </verify>
  <done>
    build_fish_mesh produces watertight PyTorch3D Meshes from FishState list. Gradients flow through all 5 state parameters and through free cross-section heights/widths. Batch API works. Zero curvature is stable. All tests pass. Public API exported from aquapose.mesh.
  </done>
</task>

</tasks>

<verification>
1. `hatch run test tests/unit/mesh/` — all tests pass
2. `hatch run check` — lint + typecheck clean
3. Gradient flow test: create a FishState with all params requiring grad, build mesh, backward through verts.sum(), verify all .grad tensors are not None and finite
4. Free mode test: pass heights/widths with requires_grad=True, verify gradients flow
5. Watertight test: every edge in the mesh is shared by exactly 2 faces
6. Import test: `from aquapose.mesh import build_fish_mesh, FishState, DEFAULT_CICHLID_PROFILE` succeeds
</verification>

<success_criteria>
- build_fish_mesh([state]) returns a pytorch3d Meshes object with watertight geometry
- Gradients flow from vertex positions back through p, psi, theta, kappa, s
- Free cross-section mode (heights/widths as grad-enabled tensors) has gradient flow
- kappa=0 and kappa=1e-6 produce finite vertices and gradients
- Batch input (list of FishStates) produces batched Meshes
- All unit tests pass, lint clean, typecheck clean
</success_criteria>

<output>
After completion, create `.planning/phases/03-fish-mesh-model-and-3d-initialization/03-01-SUMMARY.md`
</output>
