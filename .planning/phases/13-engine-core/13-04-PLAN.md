---
phase: 13-engine-core
plan: 04
type: tdd
wave: 2
depends_on:
  - "13-01"
  - "13-02"
  - "13-03"
files_modified:
  - src/aquapose/engine/pipeline.py
  - src/aquapose/engine/__init__.py
  - tests/unit/engine/test_pipeline.py
autonomous: true
requirements:
  - ENG-06
  - ENG-08

must_haves:
  truths:
    - "PosePipeline.run() executes stages in order and emits lifecycle events"
    - "The full serialized run config is written as the first artifact when PosePipeline.run() is called"
    - "PosePipeline wires stages, emits events, and coordinates observers"
    - "Removing all observers produces identical execution (observers are additive only)"
  artifacts:
    - path: "src/aquapose/engine/pipeline.py"
      provides: "PosePipeline orchestrator skeleton"
      exports: ["PosePipeline"]
      min_lines: 60
    - path: "tests/unit/engine/test_pipeline.py"
      provides: "Tests for pipeline orchestration, event emission, config artifact"
      min_lines: 60
  key_links:
    - from: "src/aquapose/engine/pipeline.py"
      to: "src/aquapose/engine/stages.py"
      via: "PosePipeline accepts list of Stage instances"
      pattern: "Stage|PipelineContext"
    - from: "src/aquapose/engine/pipeline.py"
      to: "src/aquapose/engine/events.py"
      via: "PosePipeline emits lifecycle events"
      pattern: "PipelineStart|PipelineComplete|StageStart|StageComplete"
    - from: "src/aquapose/engine/pipeline.py"
      to: "src/aquapose/engine/config.py"
      via: "PosePipeline serializes config as first artifact"
      pattern: "serialize_config"
    - from: "src/aquapose/engine/pipeline.py"
      to: "src/aquapose/engine/observers.py"
      via: "PosePipeline owns EventBus and dispatches to observers"
      pattern: "EventBus"
---

<objective>
Implement the PosePipeline orchestrator skeleton that wires stages, manages execution, emits lifecycle events via EventBus, and writes the serialized config as the first artifact.

Purpose: PosePipeline is the single canonical entrypoint (`PosePipeline.run()`) that coordinates the entire pipeline. It connects the Stage Protocol, PipelineContext, event system, and config into a working execution engine — ready for real stages to be plugged in during Phase 15.
Output: `src/aquapose/engine/pipeline.py` with PosePipeline class, plus unit tests using mock stages.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-engine-core/13-CONTEXT.md

<!-- Depends on plans 13-01, 13-02, 13-03. Reference their SUMMARY files for interfaces. -->
@.planning/phases/13-engine-core/13-01-SUMMARY.md
@.planning/phases/13-engine-core/13-02-SUMMARY.md
@.planning/phases/13-engine-core/13-03-SUMMARY.md

<interfaces>
<!-- Interfaces from prior plans in this phase. -->

From Plan 13-01 (stages.py):
- Stage Protocol: `run(self, context: PipelineContext) -> PipelineContext`
- PipelineContext: dataclass with Optional fields, .get() method

From Plan 13-02 (config.py):
- PipelineConfig: frozen dataclass (top-level config)
- load_config(): factory function
- serialize_config(): returns YAML string of config

From Plan 13-03 (events.py + observers.py):
- Events: PipelineStart, PipelineComplete, PipelineFailed, StageStart, StageComplete, FrameProcessed
- Observer Protocol: on_event(self, event: Event) -> None
- EventBus: subscribe(), unsubscribe(), emit()

From CONTEXT.md decisions:
- Single canonical entrypoint: PosePipeline.run()
- Defines stage order, manages execution state, emits lifecycle events, coordinates observers
- Owns artifact management
- Full serialized run config written as first artifact
- Run identity: timestamp-based (run_20260225_143022)
- Artifact path: ~/aquapose/runs/{run_id}/ as default, overridable via config
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PosePipeline orchestrator skeleton</name>
  <files>
    src/aquapose/engine/pipeline.py
    src/aquapose/engine/__init__.py
  </files>
  <action>
Create `src/aquapose/engine/pipeline.py`:

**`PosePipeline` class:**

```python
class PosePipeline:
    def __init__(
        self,
        stages: list[Stage],
        config: PipelineConfig,
        observers: list[Observer] | None = None,
    ) -> None:
```

Constructor:
- Store `stages` as an ordered list (explicit ordering, not DAG)
- Store `config` (frozen PipelineConfig)
- Create internal `EventBus`
- If `observers` provided, subscribe each to `Event` base type (receive all events). Alternatively, could accept more granular subscription — use discretion, but subscribing to `Event` base type is simpler for the skeleton.

**`run()` method:**

```python
def run(self) -> PipelineContext:
```

Steps:
1. **Create output directory:** Resolve `config.output_dir` (expand `~`, interpolate `{run_id}`). Create directory if needed.
2. **Write config artifact (ENG-08):** Serialize config via `serialize_config()` and write to `{output_dir}/config.yaml` as the FIRST artifact. This must happen before any stage runs.
3. **Emit `PipelineStart`:** `PipelineStart(run_id=config.run_id, config=config)`
4. **Initialize PipelineContext:** Create fresh `PipelineContext()`
5. **Execute stages in order:** For each stage:
   a. Emit `StageStart(stage_name=stage.__class__.__name__, stage_index=i)`
   b. Record wall-clock time
   c. Call `context = stage.run(context)`
   d. Record elapsed time in `context.stage_timing`
   e. Emit `StageComplete(stage_name=..., stage_index=i, elapsed_seconds=..., summary={})`
6. **On success:** Emit `PipelineComplete(run_id=config.run_id, elapsed_seconds=total)`
7. **On failure:** Catch exceptions, emit `PipelineFailed(run_id=config.run_id, error=str(e), elapsed_seconds=elapsed)`, then re-raise
8. **Return context**

**Error handling:** Wrap the stage loop in try/except. On exception, emit PipelineFailed before re-raising. This ensures observers (like timing) always get notified.

**`add_observer()` / `remove_observer()` methods** (optional convenience):
- `add_observer(observer: Observer, event_type: type[Event] = Event) -> None`
- `remove_observer(observer: Observer, event_type: type[Event] = Event) -> None`

Update `src/aquapose/engine/__init__.py`:
- Import and export `PosePipeline`
- Add to `__all__`

**Import boundary:** pipeline.py imports only from `aquapose.engine` submodules (stages, config, events, observers). NO imports from computation modules.
  </action>
  <verify>
    <automated>cd C:/Users/tucke/PycharmProjects/AquaPose && python -c "from aquapose.engine import PosePipeline; print('pipeline import OK')"</automated>
  </verify>
  <done>PosePipeline class exists with run(), add_observer(), remove_observer(). Writes config artifact first, executes stages, emits lifecycle events.</done>
</task>

<task type="auto">
  <name>Task 2: Write tests for pipeline orchestration, event emission, and config artifact</name>
  <files>tests/unit/engine/test_pipeline.py</files>
  <action>
Create `tests/unit/engine/test_pipeline.py`:

Define helper fixtures at module top:
- `MockStage`: A simple class (no inheritance!) with `run(self, context)` that appends its name to a list in context or sets a field. Must conform to Stage protocol via structural typing.
- `RecordingObserver`: A class with `on_event(self, event)` that appends events to an internal list. Conforms to Observer protocol.

**Tests to write:**

1. **`test_pipeline_runs_stages_in_order`** — Create 3 MockStages that each append their name to `context.stage_timing` (or a custom tracking mechanism). Run pipeline. Assert stages executed in order A, B, C.

2. **`test_pipeline_emits_lifecycle_events`** — Attach RecordingObserver. Run pipeline with 1 MockStage. Assert events received in order: PipelineStart, StageStart, StageComplete, PipelineComplete.

3. **`test_pipeline_writes_config_artifact`** — Create pipeline with a config that has a temp output_dir. Run pipeline. Assert `{output_dir}/config.yaml` file exists and contains valid YAML with expected fields (e.g., run_id, mode).

4. **`test_config_artifact_written_before_stages`** — Create a MockStage whose `run()` checks that `{output_dir}/config.yaml` exists at the time of execution. Assert it does (config artifact is written FIRST, before any stage).

5. **`test_pipeline_emits_failed_on_error`** — Create a MockStage that raises `RuntimeError("boom")`. Attach RecordingObserver. Run pipeline, expect RuntimeError. Assert PipelineFailed event was emitted with error message containing "boom".

6. **`test_pipeline_records_stage_timing`** — Run pipeline with 2 MockStages. Assert `context.stage_timing` has entries for both stages with positive elapsed times.

7. **`test_pipeline_no_observers_still_works`** — Run pipeline with stages but NO observers. Assert it completes normally and returns valid context. This proves observers are purely additive (Phase 13 success criterion 5 implied).

8. **`test_pipeline_context_passed_between_stages`** — First MockStage sets `context.detections = [{"cam1": []}]`. Second MockStage reads `context.detections` and verifies it's set. Assert both stages ran and context accumulated.

Use `tmp_path` pytest fixture for output directories.
Use `load_config(run_id="test_run")` with `cli_overrides` to set `output_dir` to tmp_path.

Run with: `hatch run test tests/unit/engine/test_pipeline.py -x`
  </action>
  <verify>
    <automated>cd C:/Users/tucke/PycharmProjects/AquaPose && hatch run test tests/unit/engine/test_pipeline.py -x</automated>
  </verify>
  <done>All 8 tests pass. Pipeline executes stages in order, emits lifecycle events, writes config artifact first, handles errors, and works with or without observers.</done>
</task>

</tasks>

<verification>
1. `from aquapose.engine import PosePipeline` succeeds
2. PosePipeline.run() executes stages in declared order
3. Config artifact written to disk as first action before any stage runs
4. Lifecycle events emitted: PipelineStart -> StageStart/StageComplete per stage -> PipelineComplete
5. PipelineFailed emitted on error, then exception re-raised
6. Pipeline works identically with and without observers
7. `hatch run test tests/unit/engine/test_pipeline.py -x` — all tests pass
8. `hatch run test tests/unit/engine/ -x` — ALL engine tests pass together
</verification>

<success_criteria>
- PosePipeline.run() is the single canonical entrypoint
- Config YAML is the first artifact written to the run output directory
- Stages execute in order, context flows between them
- Lifecycle events are emitted synchronously to all observers
- 8 unit tests pass covering orchestration, events, config artifact, error handling
</success_criteria>

<output>
After completion, create `.planning/phases/13-engine-core/13-04-SUMMARY.md`
</output>
