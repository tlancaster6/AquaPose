# Plan 17-05: Diagnostic Observer

---
wave: 1
depends_on: []
files_modified:
  - src/aquapose/engine/diagnostic_observer.py
  - tests/unit/engine/test_diagnostic_observer.py
  - src/aquapose/engine/__init__.py
requirements:
  - OBS-05
autonomous: true
---

## Goal

Implement a DiagnosticObserver that captures intermediate stage outputs in memory, providing dict-like access for post-hoc analysis (especially in Jupyter notebooks). The observer captures all stage outputs without selective filtering.

## Context

- **CONTEXT.md decisions**:
  - Captures ALL stage outputs (not selective) — complete snapshot of PipelineContext after each stage
  - In-memory only — no automatic persistence to disk
  - Dict-like access API: `observer.stages["detection"][frame_idx]` returns captured output
  - Stores references (no deep copy) — relies on PipelineContext's freeze-on-populate invariant
  - Snapshot HDF5 (`snapshot.h5`) is written by this observer only in diagnostic mode — deferred to CLI phase or a simple integration here
- **Events used**: StageComplete (has `stage_name`, `elapsed_seconds`, `summary`)
- **PipelineContext**: the observer needs access to context after each stage. Two approaches:
  1. Add context to StageComplete event (same pattern as PipelineComplete)
  2. Store a reference to context externally

  **Chosen approach**: Add optional `context` field to StageComplete event (typed as `object`, same pattern). This keeps the observer purely event-driven and consistent with the PipelineComplete approach from 17-02.

## Must-Haves (Goal-Backward)

1. DiagnosticObserver satisfies Observer protocol
2. After each stage completes, captures a snapshot of relevant PipelineContext fields
3. Dict-like access: `observer.stages["DetectionStage"]` returns captured stage data
4. Captures all 5 stages' outputs (not selective)
5. In-memory only — no automatic file I/O
6. Stores references, not deep copies
7. Unit tests verify capture and retrieval from synthetic events

## Tasks

<task id="17-05-T1">
<title>Add context field to StageComplete and implement DiagnosticObserver</title>
<description>
**Step 1: Extend StageComplete event**

In `src/aquapose/engine/events.py`, add a `context` field to `StageComplete`:
```python
context: object = field(default=None, compare=False)
```

Update `PosePipeline.run()` in `src/aquapose/engine/pipeline.py` to pass context when emitting StageComplete:
```python
self._bus.emit(
    StageComplete(
        stage_name=stage_name,
        stage_index=i,
        elapsed_seconds=elapsed,
        summary={},
        context=context,
    )
)
```

**Step 2: Create DiagnosticObserver**

Create `src/aquapose/engine/diagnostic_observer.py`.

Class `DiagnosticObserver`:
- Constructor: `__init__(self)` — no configuration needed
- Internal state:
  - `stages: dict[str, StageSnapshot]` — maps stage_name to captured data
  - Stage ordering preserved via insertion order (Python 3.7+ dict)
- `on_event(self, event: Event) -> None`:
  - On `StageComplete`:
    - Extract context from event (skip if None)
    - Create a `StageSnapshot` capturing references to all non-None PipelineContext fields at this point
    - Store as `self.stages[event.stage_name] = snapshot`

Class `StageSnapshot`:
- Frozen dataclass (or simple class with read-only properties):
  - `stage_name: str`
  - `stage_index: int`
  - `elapsed_seconds: float`
  - `frame_count: int | None`
  - `camera_ids: list[str] | None`
  - `detections: list | None` — reference (not copy)
  - `annotated_detections: list | None`
  - `associated_bundles: list | None`
  - `tracks: list | None`
  - `midlines_3d: list | None`
- These are direct attribute references from PipelineContext (no deep copy)
- Subscript access for convenience: `snapshot[frame_idx]` is NOT implemented at this level — users access via `snapshot.detections[frame_idx]` etc.

Actually, per CONTEXT.md: `observer.stages["detection"][frame_idx]` should return captured output. Implement `__getitem__` on StageSnapshot that returns a per-frame view. The per-frame view depends on which fields are populated:
- For detection stage: returns `detections[frame_idx]`
- For midline stage: returns `annotated_detections[frame_idx]`
- etc.

Simplest approach: `StageSnapshot.__getitem__(frame_idx)` returns a dict of all non-None per-frame fields at that index. E.g., after detection stage, `snapshot[0]` returns `{"detections": detections[0]}`. After midline stage, `snapshot[0]` returns `{"detections": detections[0], "annotated_detections": annotated_detections[0]}`.

Add `DiagnosticObserver` and `StageSnapshot` to `src/aquapose/engine/__init__.py` exports and `__all__`.
</description>
</task>

<task id="17-05-T2">
<title>Unit tests for DiagnosticObserver</title>
<description>
Create `tests/unit/engine/test_diagnostic_observer.py`.

Tests:
1. `test_diagnostic_observer_satisfies_protocol` — `isinstance(DiagnosticObserver(), Observer)` is True
2. `test_captures_stage_output` — create a PipelineContext, set `detections = [[{"cam1": [1,2]}]]`, fire StageComplete with context. Assert `observer.stages["DetectionStage"]` is not None and `snapshot.detections` is the same object (identity check with `is`)
3. `test_captures_multiple_stages` — fire two StageComplete events with different stage_names and progressively populated context. Assert both stages captured and each has correct fields
4. `test_snapshot_getitem` — after capturing detection stage, assert `snapshot[0]` returns a dict containing `"detections"` key
5. `test_stores_references_not_copies` — capture context, then verify `snapshot.detections is context.detections` (same object identity)
6. `test_skips_if_no_context` — fire StageComplete without context field, assert stage not captured, no error
7. `test_stage_timing_captured` — fire StageComplete with `elapsed_seconds=1.23`, assert `snapshot.elapsed_seconds == 1.23`
8. `test_all_stages_captured_in_full_sequence` — fire 5 StageComplete events with progressively populated context, assert all 5 stage names present in `observer.stages`

All tests use synthetic PipelineContext and StageComplete events — no real pipeline needed.
</description>
</task>

## Verification

```bash
hatch run test tests/unit/engine/test_diagnostic_observer.py -v
hatch run test tests/unit/engine/test_pipeline.py -v  # ensure StageComplete context field doesn't break existing tests
hatch run check
```

- [ ] All tests pass
- [ ] DiagnosticObserver captures all stage outputs
- [ ] Dict-like access works: `observer.stages["DetectionStage"][0]` returns per-frame data
- [ ] References stored, not copies (identity check passes)
- [ ] Existing pipeline tests still pass with new context field on StageComplete
- [ ] No stage code was modified
