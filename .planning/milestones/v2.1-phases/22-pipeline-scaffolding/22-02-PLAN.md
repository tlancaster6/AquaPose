---
phase: 22-pipeline-scaffolding
plan: 02
type: execute
wave: 2
depends_on:
  - 22-01
files_modified:
  - src/aquapose/engine/pipeline.py
  - src/aquapose/engine/config.py
  - src/aquapose/engine/diagnostic_observer.py
  - src/aquapose/core/__init__.py
  - src/aquapose/core/reconstruction/stage.py
  - tests/unit/engine/test_build_stages.py
  - tests/unit/engine/test_stages.py
  - tests/unit/engine/test_diagnostic_observer.py
  - tests/unit/core/reconstruction/test_reconstruction_stage.py
  - tests/regression/test_per_stage_regression.py
  - tests/regression/test_end_to_end_regression.py
autonomous: true
requirements:
  - PIPE-01

must_haves:
  truths:
    - "build_stages() returns 5 stages in the order Detection → TrackingStage(stub) → AssociationStage(stub) → MidlineStage → ReconstructionStage for production mode"
    - "Stub TrackingStage writes correctly-typed empty output to PipelineContext.tracks_2d, accepts and returns CarryForward unchanged, and logs a warning"
    - "Stub AssociationStage writes correctly-typed empty output to PipelineContext.tracklet_groups and logs a warning"
    - "The pipeline executes end-to-end without runtime errors on synthetic mode (with stubs)"
    - "DiagnosticObserver and StageSnapshot reflect the new PipelineContext fields (tracks_2d, tracklet_groups)"
    - "All unit tests pass under hatch run test"
  artifacts:
    - path: "src/aquapose/engine/pipeline.py"
      provides: "build_stages() with new 5-stage order and stub stages"
      contains: "TrackingStubStage"
    - path: "src/aquapose/engine/config.py"
      provides: "Updated config without old tracking/association parameters"
      contains: "TrackingConfig"
    - path: "src/aquapose/engine/diagnostic_observer.py"
      provides: "StageSnapshot with tracks_2d and tracklet_groups fields"
      contains: "tracks_2d"
  key_links:
    - from: "src/aquapose/engine/pipeline.py"
      to: "src/aquapose/core/__init__.py"
      via: "build_stages() imports stage classes"
      pattern: "from aquapose.core import"
    - from: "src/aquapose/engine/pipeline.py"
      to: "src/aquapose/core/context.py"
      via: "Stub stages populate PipelineContext.tracks_2d and tracklet_groups"
      pattern: "tracks_2d|tracklet_groups"
---

<objective>
Create stub TrackingStage and AssociationStage for the new pipeline order, rewire build_stages() to the 5-stage sequence (Detection → 2D Tracking → Association → Midline → Reconstruction), update observers and config, and adapt all affected tests to pass.

Purpose: Completes PIPE-01 — the engine wires the new stage ordering and executes without runtime errors. Stub stages establish the typed interface for Phases 24-25 to fill in.

Output: Working pipeline with new stage order, passing test suite.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-pipeline-scaffolding/22-CONTEXT.md
@.planning/phases/22-pipeline-scaffolding/22-01-SUMMARY.md

<interfaces>
<!-- After Plan 22-01, these are the key contracts -->

From src/aquapose/core/context.py (after Plan 01):
```python
@dataclass
class PipelineContext:
    frame_count: int | None = None
    camera_ids: list[str] | None = None
    detections: list[dict[str, list]] | None = None      # Stage 1 (Detection)
    tracks_2d: dict[str, list] | None = None              # Stage 2 (2D Tracking)
    tracklet_groups: list | None = None                    # Stage 3 (Association)
    annotated_detections: list[dict[str, list]] | None = None  # Stage 4 (Midline)
    midlines_3d: list[dict] | None = None                 # Stage 5 (Reconstruction)
    stage_timing: dict[str, float] = field(default_factory=dict)

@dataclass(frozen=True)
class CarryForward:
    tracks_2d_state: dict = field(default_factory=dict)  # per-camera opaque tracker state
```

From src/aquapose/core/tracking/types.py (after Plan 01):
```python
@dataclass(frozen=True)
class Tracklet2D:
    camera_id: str
    track_id: int
    frames: tuple[int, ...]
    centroids: tuple[tuple[float, float], ...]
    bboxes: tuple[tuple[float, float, float, float], ...]
    frame_status: tuple[str, ...]
```

From src/aquapose/core/association/types.py (after Plan 01):
```python
@dataclass(frozen=True)
class TrackletGroup:
    fish_id: int
    tracklets: tuple
    confidence: float | None = None
```

From src/aquapose/core/__init__.py (after Plan 01):
```python
# Exports: DetectionStage, MidlineStage, ReconstructionStage, SyntheticDataStage,
#          PipelineContext, Stage
# NOTE: AssociationStage and TrackingStage are DELETED — new stubs go in engine/pipeline.py
```

From src/aquapose/engine/config.py (current):
```python
@dataclass(frozen=True)
class AssociationConfig:
    expected_count: int = 9
    min_cameras: int = 3
    reprojection_threshold: float = 15.0

@dataclass(frozen=True)
class TrackingConfig:
    max_fish: int = 9
    min_hits: int = 5
    max_age: int = 7
    reprojection_threshold: float = 15.0
    birth_interval: int = 30
    min_cameras_birth: int = 3
    velocity_damping: float = 0.8
    velocity_window: int = 5
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create stub stages, rewire build_stages(), update config and observers</name>
  <files>
    src/aquapose/engine/pipeline.py
    src/aquapose/engine/config.py
    src/aquapose/engine/diagnostic_observer.py
    src/aquapose/core/__init__.py
    src/aquapose/core/reconstruction/stage.py
  </files>
  <action>
**1. Create stub stages in `src/aquapose/engine/pipeline.py`:**

Add two stub stage classes ABOVE the `build_stages` function (they are engine-level stubs, not core-level — per user decision, they are pass-through stubs):

```python
class TrackingStubStage:
    """Stub Stage 2: Per-camera 2D tracking (placeholder for Phase 24).

    Writes correctly-typed but empty output to PipelineContext.tracks_2d.
    Accepts and returns CarryForward unchanged, establishing the carry
    interface plumbing for Phase 24 (OC-SORT).
    Real OC-SORT implementation replaces this in Phase 24.
    """

    def run(
        self,
        context: PipelineContext,
        carry: CarryForward | None = None,
    ) -> tuple[PipelineContext, CarryForward]:
        logger.warning("TrackingStubStage is a stub — producing empty output")
        # Empty dict: no cameras have tracklets yet
        context.tracks_2d = {}
        # Pass through carry unchanged (or create default if None)
        if carry is None:
            carry = CarryForward()
        return context, carry
```

Import `CarryForward` from `aquapose.core.context` alongside `PipelineContext`.

**IMPORTANT**: The `TrackingStubStage.run()` signature differs from the `Stage` protocol (which takes only `context`). This is intentional — the tracking stage is the only stage that touches CarryForward. The pipeline runner must call it with the extra `carry` argument. Update `PosePipeline.run()` (or wherever stages are invoked) to detect the tracking stage and pass/receive `carry`. A simple approach: store `carry` as an instance attribute on PosePipeline, and check `isinstance(stage, TrackingStubStage)` before calling `run()`. Alternatively, define a `CarryStage` Protocol:
```python
class CarryStage(Protocol):
    def run(self, context: PipelineContext, carry: CarryForward | None = None) -> tuple[PipelineContext, CarryForward]: ...
```
Use `isinstance(stage, CarryStage)` to dispatch. Place this protocol in `core/context.py` alongside Stage and CarryForward.

```python
class AssociationStubStage:
    """Stub Stage 3: Cross-camera tracklet association (placeholder for Phase 25).

    Writes correctly-typed but empty output to PipelineContext.tracklet_groups.
    Real Leiden clustering implementation replaces this in Phase 25.
    """

    def run(self, context: PipelineContext) -> PipelineContext:
        logger.warning("AssociationStubStage is a stub — producing empty output")
        # Empty list: no tracklet groups identified yet
        context.tracklet_groups = []
        return context
```

Add `import logging` at the top and create `logger = logging.getLogger(__name__)`.

**2. Rewrite `build_stages()` in `src/aquapose/engine/pipeline.py`:**

The new 5-stage order is:
1. Detection (or SyntheticDataStage in synthetic mode)
2. 2D Tracking (TrackingStubStage)
3. Association (AssociationStubStage)
4. Midline (MidlineStage) — kept from v2.0
5. Reconstruction (ReconstructionStage) — kept but needs adaptation

For **production mode**, build_stages returns:
```python
[detection_stage, TrackingStubStage(), AssociationStubStage(), midline_stage, reconstruction_stage]
```

For **synthetic mode**, SyntheticDataStage replaces Detection + Midline. Since stubs produce empty output and reconstruction reads from tracklet_groups (which is empty), the reconstruction stage will also need to handle empty tracklet_groups gracefully. For now in synthetic mode, return:
```python
[synthetic_stage, TrackingStubStage(), AssociationStubStage(), reconstruction_stage]
```

The import of old AssociationStage and TrackingStage must be removed (they were deleted in Plan 01). Remove all config parameters related to old association/tracking stages from the build_stages logic. The stub stages take no config parameters.

The MidlineStage is still constructed the same way as before. The ReconstructionStage is still constructed the same way.

Remove all references to `config.association.*` and `config.tracking.*` from build_stages. The stubs don't use these configs. Keep the config dataclasses themselves for now (they'll be repurposed in Phase 24-25).

**3. Update `src/aquapose/engine/config.py`:**

Replace `AssociationConfig` with a minimal placeholder:
```python
@dataclass(frozen=True)
class AssociationConfig:
    """Config for the Association stage (stub in v2.1 Phase 22).

    Will be populated with Leiden clustering parameters in Phase 25.
    """
    pass
```

Replace `TrackingConfig` with a minimal placeholder that has the one field OC-SORT will need:
```python
@dataclass(frozen=True)
class TrackingConfig:
    """Config for the 2D Tracking stage (stub in v2.1 Phase 22).

    Will be populated with OC-SORT parameters in Phase 24.

    Attributes:
        max_coast_frames: Maximum frames to coast (predict without observation)
            before dropping a track. Placeholder; Phase 24 adds full OC-SORT config.
    """
    max_coast_frames: int = 30
```

Update `load_config` to handle the reduced config fields gracefully. The `trk_kwargs` and `assoc_kwargs` processing can remain (they just won't match any fields on the stripped-down dataclasses, which is fine — extra keys from YAML will be ignored by the dataclass constructor). Actually, to avoid constructor errors from unexpected kwargs, change the dataclass constructors to accept any remaining kwargs or, simpler, filter kwargs to only include fields that exist on each config class before constructing. The safest approach: in `load_config`, only pass kwargs that match the dataclass fields. Add a small helper or use `dataclasses.fields()` to filter.

**4. Update `src/aquapose/engine/diagnostic_observer.py`:**

Replace `associated_bundles` and `tracks` with the new field names:

In `_PER_FRAME_FIELDS`:
```python
_PER_FRAME_FIELDS = (
    "detections",
    "tracks_2d",
    "tracklet_groups",
    "annotated_detections",
    "midlines_3d",
)
```

Note: `tracks_2d` is a dict, not a list — it cannot be indexed by frame. So it should go in `_SCALAR_FIELDS` instead:
```python
_SCALAR_FIELDS = (
    "frame_count",
    "camera_ids",
    "tracks_2d",
)

_PER_FRAME_FIELDS = (
    "detections",
    "tracklet_groups",
    "annotated_detections",
    "midlines_3d",
)
```

Wait — actually `tracklet_groups` is `list[TrackletGroup]` (not per-frame list either). Re-check: in the new pipeline, tracklet_groups is a flat list of groups, not frame-indexed. So it also belongs in `_SCALAR_FIELDS`. Only `detections`, `annotated_detections`, and `midlines_3d` are truly per-frame lists. Adjust accordingly:

```python
_PER_FRAME_FIELDS = (
    "detections",
    "annotated_detections",
    "midlines_3d",
)

_SCALAR_FIELDS = (
    "frame_count",
    "camera_ids",
    "tracks_2d",
    "tracklet_groups",
)
```

Update `StageSnapshot` dataclass fields:
- Remove `associated_bundles: list | None = None`
- Remove `tracks: list | None = None`
- Add `tracks_2d: dict | None = None`
- Add `tracklet_groups: list | None = None`

Update the `on_event` method to read the new fields via getattr.

Update the docstring to reflect new field names.

**5. Update `src/aquapose/core/reconstruction/stage.py`:**

The ReconstructionStage currently reads `context.tracks` (deleted field). Since the real reconstruction rewrite happens in Phase 26 (PIPE-03), for now make it a graceful stub that:
- Checks if `context.tracklet_groups` is populated (new field). If it's an empty list (stub output), produce empty midlines_3d.
- Still reads `context.annotated_detections` if available.
- If both are empty/None, produce an empty result list sized to frame_count.

The key change: replace `context.tracks` references with `context.tracklet_groups`. Since tracklet_groups is empty from the stub, the reconstruction will produce empty results, which is the correct behavior for this phase.

Replace the `run()` method to:
```python
def run(self, context: PipelineContext) -> PipelineContext:
    # In Phase 22, tracklet_groups is empty from stub — produce empty results
    tracklet_groups = context.tracklet_groups
    if not tracklet_groups:
        # No associations yet — produce empty midlines for each frame
        frame_count = context.frame_count or 0
        context.midlines_3d = [{} for _ in range(frame_count)]
        return context

    # Full reconstruction logic (Phase 26 replaces this path)
    # ... keep existing logic but adapted to read from tracklet_groups ...
```

For the sake of this phase, since tracklet_groups is always empty (from stub), the reconstruction stage just needs to handle the empty case cleanly. The full `_assemble_midline_set` logic from tracks can be left as dead code or removed — it will be rewritten in Phase 26 anyway. The simplest approach: keep the method but make the `run()` early-return when tracklet_groups is empty.

**6. Update `src/aquapose/core/__init__.py`:**

After Plan 01, this file no longer exports AssociationStage or TrackingStage. Verify it exports: DetectionStage, MidlineStage, ReconstructionStage, SyntheticDataStage, PipelineContext, Stage. No changes needed if Plan 01 already did this correctly.
  </action>
  <verify>
    <automated>cd C:/Users/tucke/PycharmProjects/AquaPose && python -c "
from aquapose.engine.pipeline import build_stages, TrackingStubStage, AssociationStubStage
from aquapose.engine.config import PipelineConfig
from aquapose.core.context import PipelineContext, CarryForward

# Verify stubs work
ctx = PipelineContext()
ctx.frame_count = 2
ctx.camera_ids = ['cam1']
ctx.detections = [{'cam1': []}, {'cam1': []}]

ts = TrackingStubStage()
ctx, carry = ts.run(ctx)
assert ctx.tracks_2d == {}, f'Expected empty dict, got {ctx.tracks_2d}'
assert isinstance(carry, CarryForward), f'Expected CarryForward, got {type(carry)}'
assert carry.tracks_2d_state == {}, f'Expected empty dict, got {carry.tracks_2d_state}'

# Verify carry pass-through
custom_carry = CarryForward(tracks_2d_state={'cam1': {'some': 'state'}})
ctx2, carry2 = ts.run(ctx, carry=custom_carry)
assert carry2.tracks_2d_state == {'cam1': {'some': 'state'}}, 'CarryForward should pass through unchanged'

ass = AssociationStubStage()
ctx = ass.run(ctx)
assert ctx.tracklet_groups == [], f'Expected empty list, got {ctx.tracklet_groups}'

print('Stubs OK')
"</automated>
  </verify>
  <done>Stub TrackingStubStage and AssociationStubStage exist and produce correctly-typed empty output. build_stages() returns the new 5-stage order. DiagnosticObserver reflects new PipelineContext fields. ReconstructionStage handles empty tracklet_groups gracefully. Config dataclasses are simplified placeholders.</done>
</task>

<task type="auto">
  <name>Task 2: Adapt all affected tests to the new pipeline structure</name>
  <files>
    tests/unit/engine/test_build_stages.py
    tests/unit/engine/test_stages.py
    tests/unit/engine/test_diagnostic_observer.py
    tests/unit/core/reconstruction/test_reconstruction_stage.py
    tests/regression/test_per_stage_regression.py
    tests/regression/test_end_to_end_regression.py
  </files>
  <action>
**1. Rewrite `tests/unit/engine/test_build_stages.py`:**

Update all tests to reflect the new 5-stage order. Key changes:
- Production mode still returns 5 stages
- Stage order: Detection, TrackingStubStage, AssociationStubStage, MidlineStage, ReconstructionStage
- Synthetic mode: SyntheticDataStage replaces Detection+Midline → 4 stages: SyntheticDataStage, TrackingStubStage, AssociationStubStage, ReconstructionStage
- Patches must target `aquapose.core.DetectionStage`, `aquapose.core.MidlineStage`, `aquapose.core.ReconstructionStage`, `aquapose.core.SyntheticDataStage` (NOT the deleted AssociationStage/TrackingStage — stubs are inline, not patched)
- Verify TrackingStubStage and AssociationStubStage are in the correct positions
- Remove old tests that assert presence of old AssociationStage and TrackingStage mocks

**2. Update `tests/unit/engine/test_stages.py`:**

This tests PipelineContext field accumulation. Update:
- Replace `ctx.tracks = [[]]` with `ctx.tracks_2d = {}` or `ctx.tracklet_groups = []`
- Replace `assert ctx.tracks == [[]]` accordingly
- Update the `test_pipeline_context_defaults_none` to check `tracks_2d` and `tracklet_groups` instead of `associated_bundles` and `tracks`
- Keep import boundary test (it checks `aquapose.core.context` doesn't import computation modules)

**3. Update `tests/unit/engine/test_diagnostic_observer.py`:**

- In `test_all_stages_captured_in_full_sequence`, update stage_names list to:
  `["DetectionStage", "TrackingStubStage", "AssociationStubStage", "MidlineStage", "ReconstructionStage"]`
- Other tests that just test DetectionStage/MidlineStage snapshots should work unchanged since those fields are still on PipelineContext
- The timing test currently uses "TrackingStage" as stage_name — update to "TrackingStubStage" or any valid name (the observer doesn't validate names)

**4. Update `tests/unit/core/reconstruction/test_reconstruction_stage.py`:**

Read this file first to understand what it tests. The reconstruction stage now reads `tracklet_groups` instead of `tracks`. Key changes:
- Replace `ctx.tracks = [...]` with `ctx.tracklet_groups = []` (empty, since stub)
- The reconstruction stage should handle empty tracklet_groups by producing empty midlines_3d
- Existing tests that verify reconstruction behavior with full track data can be simplified: just verify that empty tracklet_groups produces empty midlines_3d (the full reconstruction tests will be rebuilt in Phase 26)
- Keep protocol conformance and import boundary tests

**5. Update regression tests:**

`tests/regression/test_per_stage_regression.py` and `tests/regression/test_end_to_end_regression.py` reference old stage names and pipeline structure. Since EVAL-01 is deferred (pipeline reorder invalidates existing regression tests), add a `pytest.skip("Regression tests deferred — pipeline reorder invalidates existing tests (EVAL-01)")` at the module level or in each test. Do NOT delete these files — they serve as templates for rebuilt regression tests post-v2.1.

**6. Run full test suite:**

After all changes, run `hatch run test` and fix any remaining failures. Common issues to watch for:
- Any remaining imports of `AssociationStage` or `TrackingStage` from `aquapose.core`
- Any test creating a PipelineContext and setting `.tracks` or `.associated_bundles`
- The `test_smoke.py` references may need updating if synthetic mode execution fails
  </action>
  <verify>
    <automated>cd C:/Users/tucke/PycharmProjects/AquaPose && hatch run test -x --timeout=60 2>&1 | tail -30</automated>
  </verify>
  <done>All unit tests pass under `hatch run test`. test_build_stages verifies the new 5-stage order. test_stages verifies PipelineContext has tracks_2d and tracklet_groups. test_diagnostic_observer verifies snapshot captures new fields. Regression tests are skipped with EVAL-01 note.</done>
</task>

</tasks>

<verification>
1. `hatch run test -x` passes with zero failures
2. `python -c "from aquapose.engine.pipeline import build_stages; from aquapose.engine.config import PipelineConfig; stages = build_stages(PipelineConfig(mode='production', calibration_path='/fake', video_dir='/fake'))"` — returns 5 stages (may fail on missing files, but no import errors)
3. Stub stages produce correctly-typed empty output: `tracks_2d = {}`, `tracklet_groups = []`
3b. TrackingStubStage returns `(context, carry)` tuple; CarryForward passes through unchanged
4. DiagnosticObserver StageSnapshot has `tracks_2d` and `tracklet_groups` fields, not `associated_bundles` or `tracks`
</verification>

<success_criteria>
- `hatch run test` passes with no failures
- build_stages() wires the new 5-stage order for both production and synthetic modes
- Stub stages log warnings and produce correctly-typed empty output
- TrackingStubStage accepts CarryForward and returns it unchanged, establishing carry interface plumbing for Phase 24
- ReconstructionStage handles empty tracklet_groups without errors
- DiagnosticObserver captures the new pipeline fields
- Config dataclasses are simplified for the new pipeline
- Regression tests are skipped (not deleted) with EVAL-01 note
</success_criteria>

<output>
After completion, create `.planning/phases/22-pipeline-scaffolding/22-02-SUMMARY.md`
</output>
