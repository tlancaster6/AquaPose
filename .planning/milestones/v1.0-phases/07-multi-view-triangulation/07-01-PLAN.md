---
phase: 07-multi-view-triangulation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aquapose/reconstruction/triangulation.py
  - src/aquapose/reconstruction/__init__.py
  - tests/unit/test_triangulation.py
autonomous: true
requirements: [RECON-03, RECON-04, RECON-05]
must_haves:
  truths:
    - "Given 2D midline observations from 3+ cameras, the system triangulates each of 15 body positions into 3D via exhaustive pairwise search and inlier re-triangulation"
    - "Given N valid triangulated 3D body points (N>=9), the system fits a cubic B-spline with exactly 7 control points and computes total arc length"
    - "A 2-camera fish is triangulated but flagged as low-confidence"
    - "Body points with only 1 camera observation are dropped; the spline interpolates through the gap"
    - "The LM refinement stub accepts a Midline3D and returns it unchanged"
    - "Width profile is converted from pixel half-widths to world metres using depth and focal length"
  artifacts:
    - path: "src/aquapose/reconstruction/triangulation.py"
      provides: "Midline3D dataclass, triangulate_midlines public API, per-body-point triangulation, spline fitting, LM stub"
      exports: ["Midline3D", "triangulate_midlines", "refine_midline_lm"]
    - path: "src/aquapose/reconstruction/__init__.py"
      provides: "Updated public API with Midline3D, triangulate_midlines, refine_midline_lm"
      contains: "Midline3D"
    - path: "tests/unit/test_triangulation.py"
      provides: "Unit tests for triangulation, spline fitting, edge cases"
  key_links:
    - from: "src/aquapose/reconstruction/triangulation.py"
      to: "src/aquapose/calibration/projection.py"
      via: "triangulate_rays and RefractiveProjectionModel.project/cast_ray"
      pattern: "from aquapose.calibration.projection import"
    - from: "src/aquapose/reconstruction/triangulation.py"
      to: "src/aquapose/reconstruction/midline.py"
      via: "Midline2D input type"
      pattern: "from aquapose.reconstruction.midline import Midline2D"
    - from: "src/aquapose/reconstruction/triangulation.py"
      to: "scipy.interpolate.make_lsq_spline"
      via: "Fixed 7-control-point B-spline fitting"
      pattern: "make_lsq_spline"
---

<objective>
Implement multi-view triangulation of 2D midline points into 3D positions and fit cubic B-splines to produce continuous 3D midlines per fish per frame.

Purpose: This is the core 3D reconstruction step — turning per-camera 2D midline observations (from Phase 6) into a single 3D midline model per fish, completing the direct triangulation pipeline.

Output: `src/aquapose/reconstruction/triangulation.py` with Midline3D dataclass, triangulate_midlines() public entry point, and unit tests.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-multi-view-triangulation/07-RESEARCH.md
@.planning/phases/07-multi-view-triangulation/07-CONTEXT.md
@.planning/phases/06-2d-medial-axis-and-arc-length-sampling/06-01-SUMMARY.md
@src/aquapose/reconstruction/midline.py
@src/aquapose/reconstruction/__init__.py
@src/aquapose/calibration/projection.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement triangulation module with Midline3D, per-body-point triangulation, spline fitting, and LM stub</name>
  <files>
    src/aquapose/reconstruction/triangulation.py
    src/aquapose/reconstruction/__init__.py
  </files>
  <action>
Create `src/aquapose/reconstruction/triangulation.py` with the following components:

**1. Midline3D dataclass:**
- Fields: fish_id (int), frame_index (int), control_points (np.ndarray shape (7,3) float32), knots (np.ndarray shape (11,) float32), degree (int, always 3), arc_length (float), half_widths (np.ndarray shape (N,) float32 in world metres), n_cameras (int), mean_residual (float), max_residual (float), is_low_confidence (bool, default False).

**2. Module-level constants:**
- SPLINE_K = 3
- SPLINE_N_CTRL = 7
- SPLINE_KNOTS: np.ndarray = [0,0,0,0, 0.25, 0.5, 0.75, 1,1,1,1] shape (11,) float64
- MIN_BODY_POINTS = 9 (= SPLINE_N_CTRL + 2, per CONTEXT.md)
- DEFAULT_INLIER_THRESHOLD = 15.0 (pixels, per research recommendation)
- N_SAMPLE_POINTS = 15 (matching Phase 6 output)

**3. Type alias:**
- `MidlineSet = dict[int, dict[str, Midline2D]]` (fish_id -> camera_id -> Midline2D)

**4. Private function `_triangulate_body_point()`:**
- Signature: `(pixels: dict[str, torch.Tensor], models: dict[str, RefractiveProjectionModel], inlier_threshold: float) -> tuple[torch.Tensor, list[str], float] | None`
- For n_cams < 2: return None (single-camera point dropped).
- For n_cams == 2: triangulate the single pair, return (pt3d, cam_ids, 0.0). No held-out scoring.
- For 3 <= n_cams <= 7: Exhaustive pairwise search per CONTEXT.md locked decision:
  - Cast rays for all cameras once upfront via models[cam_id].cast_ray(pixel.unsqueeze(0))
  - For each pair in itertools.combinations(cam_ids, 2): triangulate, score by max reprojection error across held-out cameras using models[k].project(pt3d.unsqueeze(0))
  - Keep candidate with lowest max held-out error
  - Re-triangulate using all cameras with reprojection error < inlier_threshold
  - Return (final_pt3d, inlier_cam_ids, max_residual_among_inliers)
- For n_cams > 7: Residual rejection per CONTEXT.md:
  - Triangulate using all cameras
  - Compute per-camera reprojection residuals
  - Drop cameras with residual > median + 2*sigma
  - Re-triangulate with remaining inliers
  - Return (final_pt3d, inlier_cam_ids, max_residual)

**5. Private function `_fit_spline()`:**
- Signature: `(u_param: np.ndarray, pts_3d: np.ndarray) -> tuple[np.ndarray, float] | None`
- Check len(u_param) < MIN_BODY_POINTS: return None
- Use `scipy.interpolate.make_lsq_spline(u_param, pts_3d, SPLINE_KNOTS, k=SPLINE_K)` — NOT splprep
- Extract control_points = spl.c.astype(np.float32), shape (7, 3)
- Compute arc length via 1000-point numerical integration of spl(u_fine)
- Wrap in try/except for Schoenberg-Whitney violations, return None on failure

**6. Private function `_pixel_half_width_to_metres()`:**
- Signature: `(hw_px: float, depth_m: float, focal_px: float) -> float`
- Formula: `hw_px * depth_m / focal_px` (pinhole approximation per research recommendation)
- This is approximate but sufficient for width profile (not used in triangulation itself)

**7. Public function `triangulate_midlines()`:**
- Signature: `(midline_set: MidlineSet, models: dict[str, RefractiveProjectionModel], frame_index: int = 0, inlier_threshold: float = DEFAULT_INLIER_THRESHOLD) -> dict[int, Midline3D]`
- For each fish_id in midline_set:
  - Collect camera observations. For each body point index i (0..14):
    - Gather pixels[cam_id] = torch.from_numpy(midline.points[i]).float() for each camera that has this fish
    - Call _triangulate_body_point(pixels, models, inlier_threshold)
    - Track valid_indices, pts_3d, per-point residuals, per-point n_cameras
  - Build u_param = np.array([i / (N_SAMPLE_POINTS - 1) for i in valid_indices]) — preserve original arc-length positions, do NOT re-normalize
  - If len(valid_indices) < MIN_BODY_POINTS: skip this fish (return None for it)
  - Call _fit_spline(u_param, pts_3d_array)
  - Convert half-widths to metres: for each valid body point, average half-width across inlier cameras, convert via _pixel_half_width_to_metres using the triangulated point's Z coordinate and camera focal length (use mean focal length from fx, fy). For invalid body points, interpolate from neighbors.
  - Build Midline3D with summary stats (mean and max residual across all body points), n_cameras = min cameras across body points, is_low_confidence = True if any body point had only 2 cameras
  - Store in result dict
- Return dict[int, Midline3D]

**8. Public function `refine_midline_lm()` (RECON-05 stub):**
- Signature: `(midline_3d: Midline3D, midline_set: MidlineSet, models: dict[str, RefractiveProjectionModel]) -> Midline3D`
- Docstring: "Refine 3D spline via Levenberg-Marquardt reprojection minimization. STUB: Returns midline_3d unchanged. Full implementation deferred."
- Body: `return midline_3d`

**Update `src/aquapose/reconstruction/__init__.py`:**
- Add imports for Midline3D, MidlineSet, triangulate_midlines, refine_midline_lm
- Update __all__

**Code style notes:**
- Use `from __future__ import annotations`
- Google-style docstrings on all public functions
- Type hints on all public functions
- Imports: stdlib, then third-party (numpy, scipy, torch), then local (aquapose.*)
- Convert torch<->numpy at module boundary: Midline2D.points is numpy; triangulate_rays/project are torch; Midline3D fields are numpy
  </action>
  <verify>
    Run: `hatch run python -c "from aquapose.reconstruction import Midline3D, triangulate_midlines, refine_midline_lm; print('Import OK')"` succeeds.
    Run: `hatch run lint` passes with no errors in triangulation.py.
    Run: `hatch run typecheck` passes (or only pre-existing errors in other files).
  </verify>
  <done>
    triangulation.py contains Midline3D dataclass, _triangulate_body_point (exhaustive pairwise for <=7 cams, residual rejection for >7), _fit_spline (make_lsq_spline with fixed 7 control points), _pixel_half_width_to_metres, triangulate_midlines public entry point, and refine_midline_lm stub. __init__.py exports all public symbols. All imports resolve. Lint and typecheck pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for triangulation module</name>
  <files>
    tests/unit/test_triangulation.py
  </files>
  <action>
Create `tests/unit/test_triangulation.py` with synthetic tests (no GPU, no real data). Use the existing pattern from tests/unit/test_midline.py.

**Test cases to implement:**

1. **test_triangulate_body_point_two_cameras**: Create 2 synthetic RefractiveProjectionModel mocks (or use build_synthetic_rig from tests if available), project a known 3D point into both cameras, call _triangulate_body_point. Assert returned point is within 1mm of ground truth. Assert returned cam_ids has length 2.

2. **test_triangulate_body_point_three_cameras_clean**: 3 cameras, clean observations. Assert returned point uses all 3 cameras (inlier set = all). Assert max_residual < inlier_threshold.

3. **test_triangulate_body_point_with_outlier**: 4 cameras, one with 30px offset (deliberate outlier). Assert returned inlier set excludes the outlier camera. Assert point is close to ground truth.

4. **test_triangulate_body_point_single_camera_returns_none**: 1 camera observation. Assert returns None.

5. **test_fit_spline_basic**: Generate 15 points along a known 3D curve (e.g., slight arc in XY plane at Z=1.5m). Call _fit_spline with u_param = linspace(0, 1, 15). Assert control_points shape is (7, 3). Assert arc_length is within 10% of true arc length.

6. **test_fit_spline_too_few_points**: Pass 6 points (< MIN_BODY_POINTS=9). Assert returns None.

7. **test_fit_spline_missing_points_preserves_u_param**: Generate 15 points, drop indices 3, 7, 11 (simulating failed body points). Build u_param from valid indices as i/14. Assert spline still fits and control_points shape is (7, 3).

8. **test_triangulate_midlines_integration**: Create a synthetic MidlineSet with 1 fish visible in 3 cameras. Use mock/synthetic projection models. Call triangulate_midlines. Assert result contains fish_id with valid Midline3D. Assert control_points shape (7, 3), knots shape (11,), arc_length > 0, half_widths shape (15,).

9. **test_triangulate_midlines_low_confidence_flag**: Create MidlineSet with 1 fish visible in only 2 cameras. Assert result Midline3D has is_low_confidence=True.

10. **test_refine_midline_lm_stub_passthrough**: Create a Midline3D, call refine_midline_lm. Assert returned object is identical to input.

11. **test_pixel_half_width_to_metres**: Assert _pixel_half_width_to_metres(10.0, 1.5, 1400.0) == pytest.approx(10.0 * 1.5 / 1400.0).

**For synthetic projection models in tests:**
- Use the existing `build_synthetic_rig` from test_triangulation_init.py / test_projection.py if available in the test suite.
- OR create minimal mock RefractiveProjectionModel objects: create 2-3 cameras at different positions (e.g., at Z=0, looking down at water at Z=0.75), with known K matrices (fx=fy=1400, cx=800, cy=600). Use the real RefractiveProjectionModel class with these params.
- Consult `tests/unit/calibration/` for existing synthetic camera setup patterns.

**Important test patterns:**
- All tests are CPU-only, use torch.float32
- Use `pytest.approx` for floating-point comparisons
- Import private functions directly: `from aquapose.reconstruction.triangulation import _triangulate_body_point, _fit_spline, _pixel_half_width_to_metres`
  </action>
  <verify>
    Run: `hatch run test tests/unit/test_triangulation.py -v` — all tests pass.
    Run: `hatch run test` — full suite still passes (no regressions).
  </verify>
  <done>
    11+ unit tests pass covering: 2-camera triangulation, 3-camera clean, outlier rejection, single-camera drop, spline fitting (basic, too-few-points, missing-points), full integration, low-confidence flag, LM stub passthrough, width conversion. No regressions in existing test suite.
  </done>
</task>

</tasks>

<verification>
1. `hatch run python -c "from aquapose.reconstruction import Midline3D, triangulate_midlines, refine_midline_lm"` — imports succeed
2. `hatch run test tests/unit/test_triangulation.py -v` — all triangulation tests pass
3. `hatch run test` — full suite passes, no regressions
4. `hatch run lint` — no lint errors
5. `hatch run typecheck` — no new type errors
6. Verify Midline3D.control_points is always shape (7, 3) in tests
7. Verify triangulate_midlines returns empty dict for fish with < 9 valid body points
8. Verify refine_midline_lm returns input unchanged
</verification>

<success_criteria>
- Midline3D dataclass with all fields per RESEARCH.md specification
- triangulate_midlines() produces dict[int, Midline3D] from MidlineSet input
- Exhaustive pairwise search for <=7 cameras (per locked decision, NOT random RANSAC)
- Residual rejection for >7 cameras (per locked decision)
- make_lsq_spline with fixed 7 control points (per locked decision, NOT splprep)
- Width profile in world metres (not pixels)
- LM stub is no-op passthrough (per locked decision)
- 2-camera fish flagged as low-confidence
- All unit tests pass
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/07-multi-view-triangulation/07-01-SUMMARY.md`
</output>
