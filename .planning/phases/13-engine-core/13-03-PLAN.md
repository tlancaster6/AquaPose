---
phase: 13-engine-core
plan: 03
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/aquapose/engine/events.py
  - src/aquapose/engine/observers.py
  - tests/unit/engine/test_events.py
autonomous: true
requirements:
  - ENG-03
  - ENG-04

must_haves:
  truths:
    - "Typed event dataclasses exist for pipeline lifecycle, stage lifecycle, and frame-level events"
    - "Firing a lifecycle event delivers it synchronously to all subscribed observers"
    - "Observers subscribe to specific event types and receive only those events"
    - "Observers are passive — may not mutate pipeline state"
  artifacts:
    - path: "src/aquapose/engine/events.py"
      provides: "Typed event dataclasses for pipeline, stage, and frame lifecycle"
      exports: ["PipelineStart", "PipelineComplete", "PipelineFailed", "StageStart", "StageComplete", "FrameProcessed"]
      min_lines: 40
    - path: "src/aquapose/engine/observers.py"
      provides: "Observer protocol, EventBus for typed dispatch"
      exports: ["Observer", "EventBus"]
      min_lines: 40
    - path: "tests/unit/engine/test_events.py"
      provides: "Tests for event creation, observer subscription, synchronous dispatch"
      min_lines: 50
  key_links:
    - from: "src/aquapose/engine/observers.py"
      to: "src/aquapose/engine/events.py"
      via: "EventBus dispatches typed events to subscribed observers"
      pattern: "Observer|EventBus"
    - from: "src/aquapose/engine/observers.py"
      to: "typing.Protocol"
      via: "Observer is a Protocol with on_event method"
      pattern: "class Observer.*Protocol"
---

<objective>
Implement the typed event system and Observer protocol. Events are frozen dataclasses in a 3-tier taxonomy (pipeline lifecycle, stage lifecycle, frame-level). Observers subscribe to specific event types and receive synchronous dispatch via an EventBus.

Purpose: The event/observer system decouples pipeline execution from side effects (timing, logging, export, visualization). Stages run pure computation; observers react to events without mutating state.
Output: `src/aquapose/engine/events.py` with event dataclasses, `src/aquapose/engine/observers.py` with Observer protocol and EventBus, plus unit tests.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-engine-core/13-CONTEXT.md

<interfaces>
<!-- No prior event system exists. This plan creates it from scratch. -->

From CONTEXT.md decisions:
- Events are typed dataclasses with 3-tier taxonomy:
  - Pipeline lifecycle: PipelineStart, PipelineComplete, PipelineFailed
  - Stage lifecycle: StageStart, StageComplete (with summaries)
  - Frame-level: FrameProcessed (for frame-based stages)
  - Selective domain events for stable scientific transitions
- Event naming: present-tense (PipelineStart, StageComplete, FrameProcessed)
- Synchronous delivery — pipeline blocks on each observer call. Determinism mandatory.
- Observers subscribe to specific event types (not receive-all, not method-per-event)
- Observers are passive — may not mutate pipeline state, change stage logic, or control execution flow
- Observer attachment mechanism is at Claude's discretion
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create typed event dataclasses and Observer protocol with EventBus</name>
  <files>
    src/aquapose/engine/events.py
    src/aquapose/engine/observers.py
  </files>
  <action>
**`events.py` — Typed event dataclasses (all `frozen=True`):**

Define a base `Event` class (plain frozen dataclass, not ABC) that all events inherit from — this enables `EventBus` to type-check subscriptions.

Pipeline lifecycle events:
- `PipelineStart(run_id: str, config: object)` — emitted when pipeline begins (config is generic object to avoid engine->config circular; the orchestrator passes the actual PipelineConfig)
- `PipelineComplete(run_id: str, elapsed_seconds: float)` — emitted on successful completion
- `PipelineFailed(run_id: str, error: str, elapsed_seconds: float)` — emitted on failure

Stage lifecycle events:
- `StageStart(stage_name: str, stage_index: int)` — emitted before each stage runs
- `StageComplete(stage_name: str, stage_index: int, elapsed_seconds: float, summary: dict[str, object])` — emitted after each stage completes. `summary` holds stage-specific metrics (e.g., detection count, track count).

Frame-level events:
- `FrameProcessed(stage_name: str, frame_index: int, frame_count: int)` — emitted by frame-based stages for progress tracking

All events use `@dataclass(frozen=True)`. Each has a `timestamp: float` field defaulting to `field(default_factory=time.time)`.

**`observers.py` — Observer protocol and EventBus:**

1. `Observer` as a `typing.Protocol` with `@runtime_checkable`:
   ```python
   class Observer(Protocol):
       def on_event(self, event: Event) -> None: ...
   ```

2. `EventBus` class:
   - `subscribe(event_type: type[Event], observer: Observer) -> None` — register observer for a specific event type
   - `unsubscribe(event_type: type[Event], observer: Observer) -> None` — remove observer
   - `emit(event: Event) -> None` — synchronously deliver event to all observers subscribed to that event's type. Iterate subscriptions for the event's exact type AND any parent types (so subscribing to `Event` gets everything). Delivery order = subscription order.
   - Internal storage: `dict[type[Event], list[Observer]]`
   - If an observer raises, log a warning but continue delivery to remaining observers (fault-tolerant dispatch)

**Import boundary:** Only stdlib. events.py and observers.py must NOT import from computation modules.

Update `src/aquapose/engine/__init__.py` to export all event classes, `Observer`, and `EventBus`. Add to `__all__`.
  </action>
  <verify>
    <automated>cd C:/Users/tucke/PycharmProjects/AquaPose && python -c "from aquapose.engine import EventBus, Observer, PipelineStart, StageComplete; print('event imports OK')"</automated>
  </verify>
  <done>Event dataclasses and Observer/EventBus exist. All events are frozen. EventBus dispatches synchronously.</done>
</task>

<task type="auto">
  <name>Task 2: Write tests for event creation, subscription, synchronous dispatch, and fault tolerance</name>
  <files>tests/unit/engine/test_events.py</files>
  <action>
Create `tests/unit/engine/test_events.py`:

**Tests to write:**

1. **`test_event_dataclasses_frozen`** — Create a `PipelineStart` event. Assert that attempting to mutate a field raises `FrozenInstanceError`.

2. **`test_event_has_timestamp`** — Create a `StageComplete` event. Assert `event.timestamp` is a float and is reasonably recent (within last 5 seconds).

3. **`test_observer_structural_typing`** — Define a plain class with `on_event(self, event)` method (no inheritance). Assert `isinstance(instance, Observer)` is True.

4. **`test_eventbus_delivers_to_subscriber`** — Create an EventBus, subscribe a mock observer to `StageStart`. Emit a `StageStart` event. Assert the observer's `on_event` was called exactly once with that event.

5. **`test_eventbus_filters_by_type`** — Subscribe observer A to `StageStart`, observer B to `PipelineComplete`. Emit a `StageStart` event. Assert A received it, B did not.

6. **`test_eventbus_synchronous_order`** — Subscribe observers A, B, C to `PipelineStart` in that order. Emit event. Assert they received the event in order A, B, C (use a shared list to record delivery order).

7. **`test_eventbus_base_type_subscription`** — Subscribe observer to `Event` (base type). Emit a `StageStart` event. Assert observer receives it (subscribing to base type receives all events).

8. **`test_eventbus_fault_tolerant`** — Subscribe observer A (raises RuntimeError), observer B (records event). Emit an event. Assert B still received the event despite A's failure.

9. **`test_unsubscribe`** — Subscribe observer, emit event (received), unsubscribe, emit again. Assert observer received exactly one event.

Run with: `hatch run test tests/unit/engine/test_events.py -x`
  </action>
  <verify>
    <automated>cd C:/Users/tucke/PycharmProjects/AquaPose && hatch run test tests/unit/engine/test_events.py -x</automated>
  </verify>
  <done>All 9 tests pass. Events are frozen, Observer works via structural typing, EventBus delivers synchronously with type filtering and fault tolerance.</done>
</task>

</tasks>

<verification>
1. All event dataclasses are frozen and have timestamp fields
2. Observer is a runtime_checkable Protocol
3. EventBus delivers events synchronously to type-matched subscribers
4. Subscribing to base Event type receives all events
5. Faulty observers don't break delivery to others
6. `hatch run test tests/unit/engine/test_events.py -x` — all tests pass
</verification>

<success_criteria>
- 6 event dataclasses cover pipeline, stage, and frame lifecycle
- Observer protocol uses structural typing (no inheritance required)
- EventBus supports typed subscription, synchronous dispatch, and fault tolerance
- 9 unit tests pass covering all event/observer behaviors
</success_criteria>

<output>
After completion, create `.planning/phases/13-engine-core/13-03-SUMMARY.md`
</output>
