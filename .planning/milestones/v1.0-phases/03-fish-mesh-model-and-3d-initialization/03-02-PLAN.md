---
phase: 03-fish-mesh-model-and-3d-initialization
plan: 02
type: tdd
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/aquapose/initialization/__init__.py
  - src/aquapose/initialization/keypoints.py
  - src/aquapose/initialization/triangulator.py
  - tests/unit/initialization/__init__.py
  - tests/unit/initialization/test_keypoints.py
  - tests/unit/initialization/test_triangulator.py
autonomous: true

must_haves:
  truths:
    - "Given a binary mask, extract_keypoints returns center + 2 endpoint keypoints along the major axis"
    - "Given keypoints from >=3 cameras, triangulate_keypoints produces a 3D point using refractive ray casting"
    - "Given 3 triangulated keypoints, init_fish_state produces a FishState with plausible position, heading, and scale"
    - "All initialization APIs accept lists (batch-first design)"
    - "Triangulation uses refractive ray casting from Phase 1 (not pinhole approximation)"
  artifacts:
    - path: "src/aquapose/initialization/keypoints.py"
      provides: "PCA-based keypoint extraction from binary masks"
      exports: ["extract_keypoints"]
    - path: "src/aquapose/initialization/triangulator.py"
      provides: "Multi-camera keypoint triangulation and FishState estimation"
      exports: ["triangulate_keypoint", "init_fish_state"]
    - path: "src/aquapose/initialization/__init__.py"
      provides: "Public API for initialization module"
      exports: ["extract_keypoints", "triangulate_keypoint", "init_fish_state"]
  key_links:
    - from: "src/aquapose/initialization/triangulator.py"
      to: "src/aquapose/calibration/projection.py"
      via: "cast_ray and triangulate_rays calls"
      pattern: "triangulate_rays|cast_ray"
    - from: "src/aquapose/initialization/triangulator.py"
      to: "src/aquapose/mesh/state.py"
      via: "FishState construction from triangulated keypoints"
      pattern: "FishState"
---

<objective>
Build the cold-start 3D initialization pipeline: PCA-based keypoint extraction from binary masks, multi-camera refractive triangulation, and FishState estimation from triangulated keypoints. Covers MESH-03.

Purpose: The optimizer in Phase 4 needs a plausible starting state for each fish. This module produces that starting state from binary masks without requiring any trained model or manual annotation — just PCA on mask pixels + refractive triangulation from Phase 1.

Output: Working `extract_keypoints` + `triangulate_keypoint` + `init_fish_state` with tests using synthetic masks and cameras.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-fish-mesh-model-and-3d-initialization/03-CONTEXT.md
@.planning/phases/03-fish-mesh-model-and-3d-initialization/03-RESEARCH.md
@.planning/phases/03-fish-mesh-model-and-3d-initialization/03-01-SUMMARY.md
@src/aquapose/calibration/projection.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: PCA keypoint extraction from binary masks</name>
  <files>
    src/aquapose/initialization/__init__.py
    src/aquapose/initialization/keypoints.py
    tests/unit/initialization/__init__.py
    tests/unit/initialization/test_keypoints.py
  </files>
  <action>
    **TDD: Write tests first, then implement.**

    **keypoints.py — extract_keypoints:**
    ```python
    def extract_keypoints(
        mask: np.ndarray,
    ) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
        """Extract center and endpoint keypoints from a binary mask using PCA.

        Steps:
        1. Get binary mask pixel coordinates as Nx2 array (u, v format)
        2. Centroid (mean) = center keypoint
        3. PCA on coordinates: compute 2x2 covariance, use np.linalg.eigh
        4. Major axis = eigenvector of largest eigenvalue
        5. Project all pixels onto major axis → min/max = two endpoint keypoints
        6. Enforce canonical sign: ensure endpoint_a is the one with max projection

        Args:
            mask: Binary mask, shape (H, W), uint8 (0/255) or bool.

        Returns:
            center: Centroid pixel coord, shape (2,), float32. (u, v) format.
            endpoint_a: First endpoint along major axis, shape (2,), float32.
            endpoint_b: Second endpoint along major axis, shape (2,), float32.

        Raises:
            ValueError: If mask has no foreground pixels.
        """
    ```
    - Use `np.where(mask > 0)` to get foreground pixel rows/cols
    - Convert to (u, v) = (col, row) format: `coords = np.stack([xs, ys], axis=1)`
    - Compute centroid as `coords.mean(axis=0)`
    - Compute covariance: `cov = (centered.T @ centered) / len(coords)` where `centered = coords - centroid`
    - Use `np.linalg.eigh(cov)` — returns eigenvalues sorted ascending, so `eigenvectors[:, -1]` is the major axis
    - Canonical sign (Pitfall 5 from RESEARCH): if `projections.max() < abs(projections.min())`, negate `major_axis`
    - Endpoints: `endpoint_a = center + major_axis * projections.max()`, `endpoint_b = center + major_axis * projections.min()`
    - Raise `ValueError` on empty mask

    Also implement batch wrapper:
    ```python
    def extract_keypoints_batch(
        masks: list[np.ndarray],
    ) -> list[tuple[np.ndarray, np.ndarray, np.ndarray]]:
        """Extract keypoints from multiple masks (batch-first API)."""
    ```

    **Tests (test_keypoints.py):**
    - `test_horizontal_rectangle`: 200x20 horizontal bar mask → major axis is horizontal, center near mask centroid
    - `test_vertical_rectangle`: 20x200 vertical bar mask → major axis is vertical
    - `test_diagonal_ellipse`: rotated elliptical mask → major axis follows ellipse orientation
    - `test_endpoint_distance`: endpoints are at extremes of mask along major axis (distance matches mask extent)
    - `test_canonical_sign_deterministic`: running twice on same mask produces identical results (sign consistency)
    - `test_single_pixel_mask`: 1-pixel mask → center = endpoints = that pixel (degenerate but no crash)
    - `test_empty_mask_raises`: all-zero mask → ValueError
    - `test_batch_extraction`: list of 3 masks → list of 3 keypoint tuples
  </action>
  <verify>
    `hatch run test tests/unit/initialization/test_keypoints.py` — all pass.
    `hatch run typecheck` — no errors in initialization module.
  </verify>
  <done>
    extract_keypoints correctly identifies center and major-axis endpoints from binary masks. Canonical sign enforced. Empty mask handled. Batch API works.
  </done>
</task>

<task type="auto">
  <name>Task 2: Multi-camera refractive triangulation and FishState initialization</name>
  <files>
    src/aquapose/initialization/triangulator.py
    src/aquapose/initialization/__init__.py
    tests/unit/initialization/test_triangulator.py
  </files>
  <action>
    **TDD: Write tests first, then implement.**

    **triangulator.py — triangulate_keypoint and init_fish_state:**

    ```python
    def triangulate_keypoint(
        pixel_coords: list[tuple[float, float]],
        models: list[RefractiveProjectionModel],
    ) -> torch.Tensor:
        """Triangulate a single 2D keypoint from multiple camera views.

        Uses refractive ray casting (not pinhole) from Phase 1.

        Args:
            pixel_coords: (u, v) pixel coords, one per camera. Length >= 3.
            models: RefractiveProjectionModel instances, one per camera.

        Returns:
            point_3d: Triangulated 3D point, shape (3,), float32.
        """
    ```
    - For each (pixel, model) pair: call `model.cast_ray(pixel_tensor)` → origins, directions
    - Stack all origins and directions
    - Call `triangulate_rays(origins, directions)` → 3D point
    - Require at least 3 cameras (raise ValueError if fewer)

    ```python
    def init_fish_state(
        center_3d: torch.Tensor,
        endpoint_a_3d: torch.Tensor,
        endpoint_b_3d: torch.Tensor,
    ) -> FishState:
        """Estimate a FishState from 3 triangulated keypoints.

        Heading is taken from endpoint_b toward endpoint_a (canonical direction
        from extract_keypoints). Head/tail disambiguation deferred to Phase 4
        (2-start forward + 180 flip).

        Args:
            center_3d: Fish center in world frame, shape (3,).
            endpoint_a_3d: One endpoint, shape (3,).
            endpoint_b_3d: Other endpoint, shape (3,).

        Returns:
            FishState with p=center, psi/theta from heading direction,
            kappa=0 (straight), s=distance between endpoints.
        """
    ```
    - Compute axis vector: `endpoint_a_3d - endpoint_b_3d`
    - Length = `torch.linalg.norm(axis)` → this becomes `s`
    - Unit heading = `axis / (length + 1e-8)`
    - `psi = torch.atan2(heading[1], heading[0])` — yaw from XY components
    - `theta = torch.asin(heading[2].clamp(-1, 1))` — pitch from Z component
    - `kappa = torch.zeros(())` — initialize as straight fish
    - Return `FishState(p=center_3d, psi=psi, theta=theta, kappa=kappa, s=length)`

    Also implement batch wrapper:
    ```python
    def init_fish_states_from_masks(
        masks_per_camera: list[list[np.ndarray | None]],
        models: list[RefractiveProjectionModel],
    ) -> list[FishState]:
        """Full pipeline: masks from N cameras → list of FishStates.

        Args:
            masks_per_camera: For each camera, a list of masks (one per fish).
                None entries mean that fish is not visible in that camera.
                Shape: [n_cameras][n_fish] where each entry is (H, W) or None.
            models: RefractiveProjectionModel, one per camera.

        Returns:
            List of FishState, one per fish.
        """
    ```
    - For each fish index:
      1. Collect masks from all cameras where mask is not None
      2. Call `extract_keypoints` on each mask
      3. Require at least 3 cameras with valid masks
      4. Triangulate center, endpoint_a, endpoint_b separately
      5. Call `init_fish_state` with the 3 triangulated points

    **Update __init__.py** — export: `extract_keypoints`, `extract_keypoints_batch`, `triangulate_keypoint`, `init_fish_state`, `init_fish_states_from_masks`

    **Tests (test_triangulator.py):**
    Use the synthetic rig helper from Phase 1 tests (`build_synthetic_rig`) or create a minimal synthetic camera setup:
    - Create 4+ synthetic RefractiveProjectionModel instances with known intrinsics/extrinsics
    - Place a known 3D point, project it to pixels via each model's `forward()`, then triangulate back

    Tests:
    - `test_triangulate_round_trip`: project a known 3D point through 4 cameras, triangulate back, verify within 1mm of original
    - `test_triangulate_requires_3_cameras`: passing 2 cameras raises ValueError (per success criterion 3)
    - `test_init_fish_state_horizontal`: endpoints at (0,0,1) and (0.15,0,1) → psi=0, theta=0, s=0.15
    - `test_init_fish_state_angled`: endpoints at angle → correct psi, theta computed
    - `test_init_fish_state_kappa_zero`: kappa is always 0.0 (initialization)
    - `test_init_fish_state_scale_is_endpoint_distance`: s equals distance between endpoints
    - `test_full_pipeline_synthetic`: generate synthetic masks by projecting a known 3D fish outline into 4 camera views, run `init_fish_states_from_masks`, verify resulting FishState position is within 5mm of truth and heading within 10 degrees

    For the full pipeline test, create synthetic masks by:
    1. Define a 3D line segment (fish axis) at a known position
    2. Project both endpoints to each camera using `model.forward(point_3d)`
    3. Create a binary mask with a thick line between the projected endpoints (using numpy/cv2 line drawing or simple rasterization)
    4. Run the full pipeline and compare output state to ground truth
  </action>
  <verify>
    `hatch run test tests/unit/initialization/` — all pass.
    `hatch run test tests/unit/mesh/ tests/unit/initialization/` — all Phase 3 tests pass together.
    `hatch run check` — lint + typecheck clean.
    `python -c "from aquapose.initialization import extract_keypoints, init_fish_state; print('OK')"` — import succeeds.
  </verify>
  <done>
    PCA keypoint extraction works on binary masks. Refractive triangulation round-trips within 1mm. init_fish_state computes plausible p, psi, theta, s from keypoints. Full pipeline (masks → FishState) tested with synthetic cameras and masks. Batch-first API. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `hatch run test tests/unit/initialization/` — all tests pass
2. `hatch run test tests/unit/mesh/ tests/unit/initialization/` — all Phase 3 tests pass
3. `hatch run check` — lint + typecheck clean
4. Round-trip triangulation accuracy: project known point → triangulate → error < 1mm
5. Full pipeline test: synthetic masks at known position → init_fish_state → position error < 5mm, heading error < 10 degrees
6. Import test: `from aquapose.initialization import extract_keypoints, triangulate_keypoint, init_fish_state` succeeds
</verification>

<success_criteria>
- extract_keypoints correctly identifies major axis and endpoints from binary masks
- triangulate_keypoint uses refractive ray casting (not pinhole) and round-trips within 1mm
- init_fish_state produces plausible position, heading, scale from 3 triangulated keypoints
- Full pipeline (masks → FishState) works with synthetic data
- All APIs accept lists (batch-first design)
- Minimum 3 cameras enforced for triangulation
- All tests pass, lint clean, typecheck clean
</success_criteria>

<output>
After completion, create `.planning/phases/03-fish-mesh-model-and-3d-initialization/03-02-SUMMARY.md`
</output>
