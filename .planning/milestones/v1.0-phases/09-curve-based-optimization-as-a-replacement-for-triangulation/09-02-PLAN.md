---
phase: 09-curve-based-optimization-as-a-replacement-for-triangulation
plan: 02
type: execute
wave: 2
depends_on: [09-01]
files_modified:
  - src/aquapose/reconstruction/__init__.py
  - scripts/diagnose_pipeline.py
autonomous: false
requirements: [RECON-03, RECON-04, RECON-05]
must_haves:
  truths:
    - "User can run diagnose_pipeline.py with --method curve to use the new optimizer"
    - "User can run diagnose_pipeline.py with --method triangulation to use the old method"
    - "Both methods produce comparable diagnostic visualizations for side-by-side comparison"
    - "CurveOptimizer and optimize_midlines are importable from aquapose.reconstruction"
  artifacts:
    - path: "src/aquapose/reconstruction/__init__.py"
      provides: "Public exports for CurveOptimizer, CurveOptimizerConfig"
      contains: "CurveOptimizer"
    - path: "scripts/diagnose_pipeline.py"
      provides: "--method flag dispatching to curve or triangulation"
      contains: "--method"
  key_links:
    - from: "scripts/diagnose_pipeline.py"
      to: "src/aquapose/reconstruction/curve_optimizer.py"
      via: "CurveOptimizer import and optimize_midlines call"
      pattern: "CurveOptimizer"
    - from: "src/aquapose/reconstruction/__init__.py"
      to: "src/aquapose/reconstruction/curve_optimizer.py"
      via: "re-export of public symbols"
      pattern: "from .curve_optimizer import"
---

<objective>
Wire the new curve optimizer into the diagnostic pipeline and package exports, enabling the user to compare both reconstruction methods on real data.

Purpose: The user needs to run `scripts/diagnose_pipeline.py` with both methods (old triangulation and new curve optimizer) to validate that the curve optimizer produces equivalent or better results before the old code is deleted. This plan provides the integration point.

Output: Updated `scripts/diagnose_pipeline.py` with `--method` flag, updated `__init__.py` exports, and human verification of side-by-side comparison.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-curve-based-optimization-as-a-replacement-for-triangulation/09-CONTEXT.md
@.planning/phases/09-curve-based-optimization-as-a-replacement-for-triangulation/09-01-SUMMARY.md
@src/aquapose/reconstruction/__init__.py
@scripts/diagnose_pipeline.py
@src/aquapose/reconstruction/curve_optimizer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire curve optimizer into package exports and diagnose_pipeline.py</name>
  <files>src/aquapose/reconstruction/__init__.py, scripts/diagnose_pipeline.py</files>
  <action>
**Update `src/aquapose/reconstruction/__init__.py`:**
- Add imports: `from .curve_optimizer import CurveOptimizer, CurveOptimizerConfig`
- Add to `__all__`: `"CurveOptimizer"`, `"CurveOptimizerConfig"`

**Update `scripts/diagnose_pipeline.py`:**

1. Add `--method` argument to `parse_args()`:
   ```python
   parser.add_argument(
       "--method",
       choices=["triangulation", "curve"],
       default="triangulation",
       help="Reconstruction method: triangulation (current) or curve (new optimizer)",
   )
   ```

2. In the Stage 5 (Triangulation) section, replace the inline triangulation logic with a dispatch:
   - If `args.method == "curve"`:
     - Import `CurveOptimizer, CurveOptimizerConfig` from `aquapose.reconstruction.curve_optimizer`
     - Create `optimizer = CurveOptimizer(config=CurveOptimizerConfig())`
     - For each frame, call `optimizer.optimize_midlines(midline_set, models, frame_index=frame_idx)`
     - Collect results into `midlines_3d` list (same format as existing)
     - No sub-step timing breakdown needed for curve method (the optimizer is a single call)
   - If `args.method == "triangulation"`:
     - Keep existing inline triangulation code unchanged (the detailed sub-timing code)
   - Print which method was used in the stage header: `"Running Stage 5: Triangulation ({args.method})..."`

3. Both paths produce `midlines_3d: list[dict[int, Midline3D]]` — downstream HDF5 writing, visualization, and diagnostics consume this identically. No changes needed below Stage 5.

**Key constraints (from CONTEXT.md):**
- No need to write new diagnostics — just ensure both methods are accessible from the existing script
- Wire both methods so user can compare by running the script with either --method flag
- Breaking API changes are fine — prefer clean code
  </action>
  <verify>
`hatch run python scripts/diagnose_pipeline.py --help` shows `--method` argument with choices `triangulation` and `curve`.
`hatch run lint` passes.
  </verify>
  <done>
diagnose_pipeline.py accepts --method {triangulation,curve} flag. CurveOptimizer and CurveOptimizerConfig are importable from aquapose.reconstruction.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify curve optimizer on real data via diagnose_pipeline.py</name>
  <what-built>
Curve-based 3D midline optimizer wired into the diagnostic pipeline alongside the original triangulation method. Both methods can be run and compared on the same input data.
  </what-built>
  <how-to-verify>
1. Run with the **old** method to establish baseline:
   ```
   python scripts/diagnose_pipeline.py --method triangulation --stop-frame 30 --output-dir output/diag_triangulation
   ```
   Note the timing and check `output/diag_triangulation/diagnostics/` for visualizations.

2. Run with the **new** method:
   ```
   python scripts/diagnose_pipeline.py --method curve --stop-frame 30 --output-dir output/diag_curve
   ```
   Note the timing and check `output/diag_curve/diagnostics/` for visualizations.

3. Compare:
   - **Speed**: Is the curve method faster than ~76s for 30 frames? (Required per CONTEXT.md)
   - **Visual quality**: Do the spline camera overlays in `diagnostics/` look reasonable? Are fish midlines well-aligned to the 2D silhouettes?
   - **Residuals**: Check the diagnostic report for mean/max residuals. Are they comparable or better?
   - **Arc lengths**: Do the arc length histograms show values in the 70-100mm range?
   - **Failure rate**: How many fish per frame are successfully reconstructed vs skipped?
  </how-to-verify>
  <resume-signal>Type "approved" if results are acceptable, or describe specific issues to address</resume-signal>
</task>

</tasks>

<verification>
1. `python scripts/diagnose_pipeline.py --help` shows --method flag
2. Both `--method triangulation` and `--method curve` run without errors on real data
3. CurveOptimizer importable from `aquapose.reconstruction`
4. Curve method timing < 76s for 30 frames
</verification>

<success_criteria>
- User can toggle between triangulation and curve methods via --method flag
- Both methods produce full diagnostic output (HDF5, overlays, report)
- Curve method produces visually reasonable 3D midlines comparable to triangulation
- Curve method is faster than the current ~76s baseline
</success_criteria>

<output>
After completion, create `.planning/phases/09-curve-based-optimization-as-a-replacement-for-triangulation/09-02-SUMMARY.md`
</output>
