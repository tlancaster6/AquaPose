---
phase: 15-stage-migrations
plan: 05
type: execute
wave: 5
depends_on: [15-04]
files_modified:
  - src/aquapose/core/reconstruction/__init__.py
  - src/aquapose/core/reconstruction/types.py
  - src/aquapose/core/reconstruction/backends/__init__.py
  - src/aquapose/core/reconstruction/backends/triangulation.py
  - src/aquapose/core/reconstruction/backends/curve_optimizer.py
  - src/aquapose/core/reconstruction/stage.py
  - src/aquapose/engine/config.py
  - src/aquapose/engine/pipeline.py
  - src/aquapose/core/__init__.py
  - tests/unit/core/reconstruction/__init__.py
  - tests/unit/core/reconstruction/test_reconstruction_stage.py
  - .planning/phases/15-stage-migrations/15-BUG-LEDGER.md
autonomous: true
requirements: [STG-05]

must_haves:
  truths:
    - ReconstructionStage satisfies engine.stages.Stage protocol via structural typing
    - ReconstructionStage.run(context) reads context.tracks and context.annotated_detections and produces context.midlines_3d
    - Triangulation backend fully implemented — RANSAC multi-view triangulation + view-angle weighting + B-spline fitting
    - Curve optimizer backend fully implemented — correspondence-free 3D B-spline optimization via chamfer distance
    - Backend selected via config.reconstruction.backend ("triangulation" or "curve_optimizer")
    - No imports from engine/ in any core/reconstruction/ module
    - "engine/pipeline.py updated with a build_stages(config) factory (or equivalent) that imports all 5 stage classes from core/, constructs them from PipelineConfig sub-configs, and returns the ordered stage list. PosePipeline can be instantiated with build_stages(config) as its stages argument."
    - PosePipeline.run() with all 5 stages wired completes without error (smoke test documented)
    - Bug ledger documents all v1.0 quirks preserved during porting
  artifacts:
    - src/aquapose/core/reconstruction/__init__.py
    - src/aquapose/core/reconstruction/types.py
    - src/aquapose/core/reconstruction/stage.py
    - src/aquapose/core/reconstruction/backends/triangulation.py
    - src/aquapose/core/reconstruction/backends/curve_optimizer.py
    - tests/unit/core/reconstruction/test_reconstruction_stage.py
    - .planning/phases/15-stage-migrations/15-BUG-LEDGER.md
  key_links:
    - ReconstructionStage reads PipelineContext.tracks (Stage 4) and PipelineContext.annotated_detections (Stage 2)
    - ReconstructionStage writes PipelineContext.midlines_3d
    - Triangulation backend delegates to aquapose.reconstruction.triangulation.triangulate_midlines
    - Curve optimizer backend delegates to aquapose.reconstruction.curve_optimizer.optimize_midlines
    - core/__init__.py updated with all 5 stage exports
    - engine/pipeline.py updated with build_stages() factory that constructs all 5 stages from config
---

<objective>
Port the Reconstruction stage (Stage 5) as a pure Stage Protocol implementor in core/reconstruction/, wire all 5 stages into PosePipeline, and finalize Phase 15.

Purpose: Reconstruction is the final pipeline stage. It takes tracked fish with 2D midlines and triangulates/optimizes them into 3D B-spline midlines. Both the triangulation and curve optimizer backends have working v1.0 code. This plan also creates the bug ledger and updates core/__init__.py to export all 5 stages.

Output: A ReconstructionStage class in core/reconstruction/ with two backends, the completed bug ledger, and all 5 stages exported from core/.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-stage-migrations/15-CONTEXT.md

@src/aquapose/engine/stages.py
@src/aquapose/engine/config.py
@src/aquapose/engine/pipeline.py
@src/aquapose/reconstruction/triangulation.py (v1.0 triangulate_midlines — port this behavior)
@src/aquapose/reconstruction/curve_optimizer.py (v1.0 optimize_midlines — port this behavior)
@src/aquapose/reconstruction/midline.py (MidlineExtractor, Midline2D, MidlineSet type alias)
@src/aquapose/pipeline/stages.py (v1.0 run_triangulation — port this behavior)
@src/aquapose/pipeline/orchestrator.py (v1.0 reconstruction wiring)
@src/aquapose/calibration/projection.py (RefractiveProjectionModel)

<interfaces>
<!-- Engine contracts -->
From src/aquapose/engine/stages.py:
```python
@dataclass
class PipelineContext:
    annotated_detections: list[dict[str, list]] | None = None  # Stage 2 (has midline data)
    tracks: list[list] | None = None                           # Stage 4 (has fish IDs)
    midlines_3d: list[dict] | None = None                      # Stage 5 writes this
```

From src/aquapose/engine/config.py:
```python
@dataclass(frozen=True)
class ReconstructionConfig:
    backend: str = "triangulation"
```

<!-- v1.0 reconstruction API -->
From src/aquapose/reconstruction/triangulation.py:
```python
MidlineSet = dict[int, dict[str, Midline2D]]

@dataclass
class Midline3D:
    fish_id: int
    frame_index: int
    control_points: np.ndarray  # (7, 3)
    knots: np.ndarray           # (11,)
    degree: int
    arc_length: float
    half_widths: np.ndarray     # (N,)
    n_cameras: int
    mean_residual: float
    max_residual: float
    is_low_confidence: bool = False
    per_camera_residuals: dict[str, float] | None = None

def triangulate_midlines(midline_set, models, frame_index=0, ...) -> dict[int, Midline3D]: ...
```

From src/aquapose/reconstruction/curve_optimizer.py:
```python
def optimize_midlines(midline_set, models, prev_results=None, ...) -> dict[int, Midline3D]: ...
```

<!-- v1.0 data flow for reconstruction -->
From pipeline/stages.py run_triangulation:
- Takes midline_sets (list of MidlineSet) and models
- For each frame, calls triangulate_midlines(midline_set, models, frame_index)
- Returns list[dict[int, Midline3D]]

The new Reconstruction stage must build MidlineSet from context.tracks + context.annotated_detections:
- For each frame, for each tracked fish, look up its camera_detections (cam_id -> det_idx)
- For each camera, retrieve the Midline2D from annotated_detections at that detection index
- Assemble into MidlineSet: dict[fish_id, dict[cam_id, Midline2D]]
- Pass to triangulate_midlines or optimize_midlines
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create core/reconstruction/ module with both backends and stage</name>
  <files>
    src/aquapose/core/reconstruction/__init__.py
    src/aquapose/core/reconstruction/types.py
    src/aquapose/core/reconstruction/backends/__init__.py
    src/aquapose/core/reconstruction/backends/triangulation.py
    src/aquapose/core/reconstruction/backends/curve_optimizer.py
    src/aquapose/core/reconstruction/stage.py
    src/aquapose/engine/config.py
    src/aquapose/engine/pipeline.py
    src/aquapose/core/__init__.py
  </files>
  <action>
Create the core/reconstruction/ package:

1. **types.py** — Re-export `Midline3D`, `MidlineSet` from `aquapose.reconstruction.triangulation` and `Midline2D` from `aquapose.reconstruction.midline`. These are the canonical reconstruction types.

2. **backends/__init__.py** — Backend registry. Supports "triangulation" (default) and "curve_optimizer". Raise ValueError for unknown.

3. **backends/triangulation.py** — Triangulation backend:
   - Constructor accepts `calibration_path: str | Path`, `skip_camera_id: str = "e3v8250"`, `inlier_threshold: float = 50.0`, `snap_threshold: float = 20.0`, `max_depth: float | None = None`
   - Loads calibration and builds RefractiveProjectionModel dict at construction
   - Exposes `reconstruct_frame(frame_idx: int, midline_set: MidlineSet) -> dict[int, Midline3D]`:
     - Delegates to existing `triangulate_midlines()` from `aquapose.reconstruction.triangulation`
     - Returns the result directly

4. **backends/curve_optimizer.py** — Curve optimizer backend:
   - Constructor accepts `calibration_path`, `skip_camera_id`, plus optimizer-specific params (lr, max_iter, etc. from existing curve_optimizer.py defaults)
   - Loads calibration and builds models at construction
   - Maintains previous frame results for warm-starting (stateful like v1.0)
   - Exposes `reconstruct_frame(frame_idx: int, midline_set: MidlineSet) -> dict[int, Midline3D]`:
     - Delegates to existing `optimize_midlines()` from `aquapose.reconstruction.curve_optimizer`
     - Passes prev_results for warm-starting
     - Returns the result

5. **stage.py** — `ReconstructionStage` class satisfying Stage Protocol:
   - Constructor: accepts `calibration_path: str | Path`, `skip_camera_id: str = "e3v8250"`, `backend: str = "triangulation"`, plus backend-specific kwargs
   - Creates the selected backend at construction
   - `run(self, context)`:
     - Reads context.tracks (per-frame list of FishTrack) and context.annotated_detections (per-frame per-camera detections with midline data)
     - For each frame, assembles MidlineSet:
       - For each confirmed FishTrack, get camera_detections (cam_id -> det_idx)
       - For each (cam_id, det_idx), look up the corresponding Midline2D from annotated_detections
       - Build dict[fish_id, dict[cam_id, Midline2D]]
     - Calls backend.reconstruct_frame(frame_idx, midline_set)
     - Sets context.midlines_3d = list of per-frame dicts
     - Returns context

   The MidlineSet assembly logic is NEW code that bridges the decoupled pipeline stages. In v1.0, the MidlineExtractor had direct access to tracks and masks. In the new model, the Reconstruction stage must assemble the same structure from the outputs of earlier stages.

   CRITICAL: core/reconstruction/ must NOT import from engine/.

6. **__init__.py** — Export ReconstructionStage, Midline3D.

7. **engine/config.py** — Extend ReconstructionConfig:
   ```python
   @dataclass(frozen=True)
   class ReconstructionConfig:
       backend: str = "triangulation"
       inlier_threshold: float = 50.0
       snap_threshold: float = 20.0
       max_depth: float | None = None
   ```

8. **core/__init__.py** — Update to export all 5 stage classes:
   ```python
   from aquapose.core.detection import DetectionStage
   from aquapose.core.midline import MidlineStage
   from aquapose.core.association import AssociationStage
   from aquapose.core.tracking import TrackingStage
   from aquapose.core.reconstruction import ReconstructionStage
   ```

9. **engine/pipeline.py** — Add a `build_stages(config: PipelineConfig) -> list[Stage]` factory function:
   - Import all 5 stage classes from `aquapose.core`
   - Construct each stage from its corresponding sub-config in PipelineConfig (detection, midline, association, tracking, reconstruction configs)
   - Return them as an ordered list: `[DetectionStage(...), MidlineStage(...), AssociationStage(...), TrackingStage(...), ReconstructionStage(...)]`
   - This factory is the canonical way to wire stages into PosePipeline:
     ```python
     stages = build_stages(config)
     pipeline = PosePipeline(stages=stages, config=config)
     context = pipeline.run()
     ```
   - The function lives in `engine/pipeline.py` alongside PosePipeline since it is orchestration logic (engine/ imports from core/, never the reverse)
   - Each stage receives only the config fields it needs (calibration_path, model paths, backend selection, thresholds, etc.)

10. **Bug Ledger** — Create `.planning/phases/15-stage-migrations/15-BUG-LEDGER.md` documenting all v1.0 quirks preserved during porting. At minimum include:
   - Stage 3 output not consumed by Stage 4 (Stage 4 re-derives association via FishTracker.update())
   - Any hardcoded thresholds extracted to config
   - Any behavioral differences between the decoupled pipeline and v1.0's monolithic orchestrator
  </action>
  <verify>
    <automated>hatch run python -c "from aquapose.core.reconstruction import ReconstructionStage, Midline3D; from aquapose.core import DetectionStage, MidlineStage, AssociationStage, TrackingStage, ReconstructionStage; from aquapose.engine.pipeline import build_stages; print('all 5 stages importable + build_stages factory exists')"</automated>
  </verify>
  <done>
    - ReconstructionStage exists in core/reconstruction/stage.py
    - Triangulation backend fully delegates to existing triangulate_midlines()
    - Curve optimizer backend fully delegates to existing optimize_midlines()
    - run() assembles MidlineSet from tracks + annotated_detections, produces context.midlines_3d
    - All 5 stages exported from core/__init__.py
    - build_stages() factory in engine/pipeline.py constructs all 5 stages from PipelineConfig
    - PosePipeline can be instantiated with build_stages(config)
    - Bug ledger created with preserved v1.0 quirks
    - No imports from engine/ in core/reconstruction/
  </done>
</task>

<task type="auto">
  <name>Task 2: Interface tests for ReconstructionStage and full pipeline smoke test</name>
  <files>
    tests/unit/core/reconstruction/__init__.py
    tests/unit/core/reconstruction/test_reconstruction_stage.py
  </files>
  <action>
Create interface tests:

1. **test_reconstruction_stage_satisfies_protocol** — Assert isinstance(stage, Stage) passes.

2. **test_reconstruction_stage_populates_midlines_3d** — Create stage with mocked calibration/models. Feed PipelineContext with synthetic tracks and annotated_detections. Assert context.midlines_3d is populated as list of per-frame dicts.

3. **test_triangulation_backend_delegates** — Mock triangulate_midlines and verify the triangulation backend calls it with the correct MidlineSet structure.

4. **test_curve_optimizer_backend_delegates** — Mock optimize_midlines and verify the curve optimizer backend calls it.

5. **test_backend_selection_via_config** — Verify "triangulation" and "curve_optimizer" strings resolve to the correct backends.

6. **test_backend_registry_unknown_raises** — Assert ValueError for unknown backend kind.

7. **test_import_boundary** — Inspect source of all modules in core/reconstruction/ and assert no imports from aquapose.engine.

8. **test_midline_set_assembly** — Verify that the stage correctly assembles MidlineSet from tracks + annotated_detections. Create synthetic FishTrack objects with camera_detections, synthetic annotated_detections with Midline2D objects, and verify the assembled MidlineSet has the correct structure.

9. **test_all_stages_importable** — Verify all 5 stages can be imported from core/:
   ```python
   from aquapose.core import (
       DetectionStage, MidlineStage, AssociationStage,
       TrackingStage, ReconstructionStage
   )
   ```

10. **test_build_stages_returns_5_stages** — Verify `build_stages(config)` returns a list of 5 Stage instances in the correct order. Mock model/calibration loading. Assert each element satisfies the Stage Protocol and types are in order: DetectionStage, MidlineStage, AssociationStage, TrackingStage, ReconstructionStage.

11. **test_pose_pipeline_instantiable_with_build_stages** — Verify that `PosePipeline(stages=build_stages(config), config=config)` can be instantiated without error. This is the smoke test that proves the wiring works end-to-end at construction time.

Mock all heavy dependencies (model loading, calibration, video). Focus on verifying:
- Stage Protocol conformance
- MidlineSet assembly correctness
- Backend delegation
- Data flow through context fields
  </action>
  <verify>
    <automated>hatch run test tests/unit/core/reconstruction/test_reconstruction_stage.py -x -v</automated>
  </verify>
  <done>
    - All tests pass
    - ReconstructionStage confirmed to satisfy Stage Protocol
    - Both backends tested (triangulation and curve_optimizer delegation)
    - MidlineSet assembly verified
    - All 5 stages importable from core/
    - Import boundary verified
  </done>
</task>

</tasks>

<verification>
1. `isinstance(ReconstructionStage(...), Stage)` returns True
2. `hatch run test tests/unit/core/reconstruction/ -v` — all pass
3. `hatch run test tests/unit/core/ -v` — all 5 stage test suites pass
4. `hatch run check` — no lint or type errors
5. All 5 stages importable from core/__init__.py
6. `build_stages(config)` returns 5 ordered Stage instances
7. `PosePipeline(stages=build_stages(config), config=config)` instantiates without error
8. grep for "engine" in src/aquapose/core/ (excluding __pycache__) returns nothing meaningful
9. Bug ledger exists at .planning/phases/15-stage-migrations/15-BUG-LEDGER.md
</verification>

<success_criteria>
- ReconstructionStage satisfies Stage Protocol via structural typing
- Triangulation and curve optimizer backends both fully implemented
- run() assembles MidlineSet and produces context.midlines_3d
- All 5 stages exported from core/ and satisfy Stage Protocol
- build_stages() factory in engine/pipeline.py constructs and wires all 5 stages from PipelineConfig
- PosePipeline instantiable with build_stages(config) — pipeline wiring proven
- Bug ledger documents preserved v1.0 quirks
- Interface tests pass for all 5 stages
- No engine/ imports in core/
</success_criteria>

<output>
After completion, create `.planning/phases/15-stage-migrations/15-05-SUMMARY.md`
</output>
