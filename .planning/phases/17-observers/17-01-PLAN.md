# Plan 17-01: Timing Observer

---
wave: 1
depends_on: []
files_modified:
  - src/aquapose/engine/timing.py
  - tests/unit/engine/test_timing.py
  - src/aquapose/engine/__init__.py
requirements:
  - OBS-01
autonomous: true
---

## Goal

Implement a TimingObserver that records per-stage and total pipeline wall-clock time by subscribing to StageStart, StageComplete, PipelineStart, and PipelineComplete events. The observer produces a timing report (log + optional file) without modifying any stage code.

## Context

- **Observer protocol** is in `src/aquapose/engine/observers.py` — any class with `on_event(self, event: Event) -> None` satisfies it
- **Events** are in `src/aquapose/engine/events.py` — StageStart, StageComplete (has `elapsed_seconds`), PipelineStart, PipelineComplete (has `elapsed_seconds`), PipelineFailed (has `elapsed_seconds`)
- **PosePipeline** already records `context.stage_timing` and emits all lifecycle events
- **CONTEXT.md decision**: Timing observer is always-on (attached to every run regardless of mode)
- The timing observer supplements `context.stage_timing` with observer-side recording and a formatted report

## Must-Haves (Goal-Backward)

1. TimingObserver class satisfies Observer protocol (structural typing, no inheritance)
2. Records per-stage elapsed time from StageComplete events
3. Records total pipeline time from PipelineComplete/PipelineFailed events
4. Produces a formatted timing report (accessible as string and logged via Python logging)
5. Optionally writes timing report to a file (path configurable)
6. Unit tests verify timing capture from synthetic events and report formatting

## Tasks

<task id="17-01-T1">
<title>Implement TimingObserver class</title>
<description>
Create `src/aquapose/engine/timing.py` with the `TimingObserver` class.

Requirements:
- Class has `on_event(self, event: Event) -> None` method (satisfies Observer protocol)
- Constructor takes optional `output_path: str | Path | None = None` (if set, writes report to file on PipelineComplete)
- Internal state: `stage_times: dict[str, float]` mapping stage_name -> elapsed_seconds
- Internal state: `total_time: float | None` for total pipeline time
- Internal state: `run_id: str` captured from PipelineStart
- On `StageComplete`: store `event.stage_name -> event.elapsed_seconds`
- On `PipelineComplete`: store `event.elapsed_seconds` as total_time, log the report, optionally write to file
- On `PipelineFailed`: store `event.elapsed_seconds` as total_time, log partial report with failure note
- `report() -> str` method: returns a formatted multi-line string with:
  - Header with run_id
  - Per-stage rows: stage_name, elapsed time (seconds, 2 decimal places)
  - Total time row
  - Percentage breakdown per stage
- Log the report at INFO level via `logging.getLogger(__name__)`
- If `output_path` is set, write `report()` string to that path on pipeline completion

Module docstring: "Timing observer for per-stage and total pipeline wall-clock profiling."

Add `TimingObserver` to `src/aquapose/engine/__init__.py` exports and `__all__`.
</description>
</task>

<task id="17-01-T2">
<title>Unit tests for TimingObserver</title>
<description>
Create `tests/unit/engine/test_timing.py`.

Tests:
1. `test_timing_observer_captures_stage_times` — fire StageComplete events with known elapsed_seconds, assert `observer.stage_times` matches
2. `test_timing_observer_captures_total_time` — fire PipelineComplete with known elapsed, assert `observer.total_time` matches
3. `test_timing_report_format` — fire a full sequence (PipelineStart, StageStart/StageComplete x3, PipelineComplete), call `report()`, assert it contains each stage name and the total
4. `test_timing_observer_writes_file` — pass `output_path` to a tmp_path file, fire full sequence, assert file exists and contains the report
5. `test_timing_observer_handles_failure` — fire PipelineFailed instead of PipelineComplete, assert total_time is set and report contains failure indication
6. `test_timing_observer_satisfies_protocol` — assert `isinstance(TimingObserver(), Observer)` is True

All tests use synthetic events (no real pipeline needed). Use pytest `tmp_path` fixture for file tests.
</description>
</task>

## Verification

```bash
hatch run test tests/unit/engine/test_timing.py -v
hatch run check
```

- [ ] All tests pass
- [ ] `TimingObserver` satisfies `Observer` protocol via `isinstance` check
- [ ] Report includes per-stage times, total time, and percentage breakdown
- [ ] File output works when `output_path` is provided
- [ ] No stage code was modified
