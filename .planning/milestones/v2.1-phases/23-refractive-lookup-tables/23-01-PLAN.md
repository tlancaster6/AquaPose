---
phase: 23-refractive-lookup-tables
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/aquapose/calibration/luts.py
  - src/aquapose/calibration/__init__.py
  - src/aquapose/engine/config.py
  - tests/unit/calibration/test_luts.py
autonomous: true
requirements:
  - LUT-01

must_haves:
  truths:
    - "ForwardLUT maps every pixel coordinate on a camera's grid to a 3D refracted ray (origin + direction) via bilinear interpolation, matching RefractiveProjectionModel.cast_ray() within floating-point tolerance"
    - "ForwardLUT is serialized to disk as one .npz file per camera and reloaded without regeneration when the calibration hash matches"
    - "LutConfig frozen dataclass is added to PipelineConfig with tank geometry and voxel resolution parameters"
    - "generate_forward_luts() builds ForwardLUT objects for all ring cameras from CalibrationData"
    - "ForwardLUT.cast_ray() returns origin and direction tensors identical to RefractiveProjectionModel.cast_ray() within 0.5 px reprojection tolerance"
  artifacts:
    - path: "src/aquapose/calibration/luts.py"
      provides: "ForwardLUT class, generate_forward_luts(), save/load serialization"
      contains: "ForwardLUT"
    - path: "src/aquapose/engine/config.py"
      provides: "LutConfig frozen dataclass with tank_diameter, tank_height, voxel_resolution_m, margin_fraction"
      contains: "LutConfig"
    - path: "tests/unit/calibration/test_luts.py"
      provides: "Unit tests for ForwardLUT generation, interpolation accuracy, serialization round-trip"
      contains: "test_forward_lut"
  key_links:
    - from: "src/aquapose/calibration/luts.py"
      to: "src/aquapose/calibration/projection.py"
      via: "RefractiveProjectionModel.cast_ray() used to populate forward LUT grid"
      pattern: "cast_ray"
    - from: "src/aquapose/calibration/luts.py"
      to: "src/aquapose/calibration/loader.py"
      via: "CalibrationData provides camera intrinsics, extrinsics, water_z, and refractive indices"
      pattern: "CalibrationData"
---

<objective>
Build the forward lookup table (pixel to ray) system: a ForwardLUT class that precomputes a grid of refracted rays per camera, supports bilinear interpolation for arbitrary pixel queries, and serializes/deserializes to .npz files with hash-based cache invalidation.

Purpose: Eliminates per-frame refraction math during association scoring (Phase 25). Each detection centroid lookup becomes a bilinear interpolation instead of a full Snell's law computation with K_inv, ray-plane intersection, and vectorized refraction.

Output: ForwardLUT class in calibration/luts.py, LutConfig in engine/config.py, unit tests validating interpolation accuracy against on-the-fly cast_ray().
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-refractive-lookup-tables/23-CONTEXT.md

<interfaces>
<!-- Key types and contracts the executor needs -->

From src/aquapose/calibration/projection.py:
```python
class RefractiveProjectionModel:
    def __init__(self, K, R, t, water_z, normal, n_air, n_water): ...
    def cast_ray(self, pixels: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:
        """Cast rays from pixel coordinates into the scene.
        Args: pixels: 2D pixel coordinates (u, v), shape (N, 2), float32.
        Returns: origins (N, 3), directions (N, 3) — on water surface, into water."""
    def project(self, points: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:
        """Project 3D world points to 2D pixel coordinates.
        Returns: pixels (N, 2), valid (N,) boolean mask."""
```

From src/aquapose/calibration/loader.py:
```python
@dataclass
class CameraData:
    name: str
    K: torch.Tensor          # (3, 3), float32
    dist_coeffs: torch.Tensor # (N,), float64
    R: torch.Tensor          # (3, 3), float32
    t: torch.Tensor          # (3,), float32
    image_size: tuple[int, int]  # (width, height)
    is_fisheye: bool
    is_auxiliary: bool

@dataclass
class CalibrationData:
    cameras: dict[str, CameraData]
    water_z: float
    interface_normal: torch.Tensor  # (3,), float32
    n_air: float
    n_water: float

    @property
    def ring_cameras(self) -> list[str]: ...  # non-auxiliary, sorted
    def camera_positions(self) -> dict[str, torch.Tensor]: ...  # C = -R^T @ t
```

From src/aquapose/engine/config.py:
```python
@dataclass(frozen=True)
class PipelineConfig:
    run_id: str = ""
    output_dir: str = ""
    video_dir: str = ""
    calibration_path: str = ""
    mode: str = "production"
    detection: DetectionConfig = ...
    midline: MidlineConfig = ...
    association: AssociationConfig = ...
    tracking: TrackingConfig = ...
    reconstruction: ReconstructionConfig = ...
    synthetic: SyntheticConfig = ...
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add LutConfig to engine/config.py and create ForwardLUT class with generation and serialization</name>
  <files>
    src/aquapose/engine/config.py
    src/aquapose/calibration/luts.py
    src/aquapose/calibration/__init__.py
  </files>
  <action>
**1. Add LutConfig to `src/aquapose/engine/config.py`:**

Add a new frozen dataclass `LutConfig` alongside the other stage configs:

```python
@dataclass(frozen=True)
class LutConfig:
    """Config for refractive lookup table generation.

    Attributes:
        tank_diameter: Cylindrical tank diameter in metres.
        tank_height: Tank depth (water column height) in metres.
        voxel_resolution_m: Voxel grid spacing in metres (default 0.02 = 2 cm).
        margin_fraction: Fractional margin beyond tank dimensions for LUT coverage (default 0.1 = 10%).
        forward_grid_step: Pixel step size for forward LUT grid (default 1 = every pixel).
    """
    tank_diameter: float = 2.0
    tank_height: float = 1.0
    voxel_resolution_m: float = 0.02
    margin_fraction: float = 0.1
    forward_grid_step: int = 1
```

Add `lut: LutConfig` field to `PipelineConfig` with `default_factory=LutConfig`. Add `lut_kwargs` handling in `load_config()` following the same pattern as other stage configs (YAML key `"lut"`, CLI override support, `_filter_fields` if needed).

**2. Create `src/aquapose/calibration/luts.py`:**

This module implements the forward LUT system. Key components:

**ForwardLUT class:**
```python
@dataclass
class ForwardLUT:
    """Forward lookup table mapping pixel coordinates to refracted 3D rays.

    Precomputes a regular grid of rays via RefractiveProjectionModel.cast_ray(),
    then serves arbitrary pixel queries via bilinear interpolation over the grid.

    Attributes:
        camera_id: Camera identifier.
        grid_origins: Ray origins on water surface, shape (H, W, 3), float32.
        grid_directions: Unit ray directions into water, shape (H, W, 3), float32.
        grid_step: Pixel spacing of the precomputed grid.
        image_size: (width, height) of the camera image.
    """
```

**ForwardLUT.cast_ray(pixels)** method:
- Input: pixels tensor shape (N, 2), float32 — arbitrary (u, v) coordinates
- Convert pixel coords to grid indices: `gx = u / grid_step`, `gy = v / grid_step`
- Bilinear interpolation over grid_origins and grid_directions using the four surrounding grid points
- Re-normalize interpolated directions to unit vectors
- Return: (origins, directions) each shape (N, 3)
- Implementation: Use floor/ceil of grid indices, compute weights `(1-fx)*(1-fy)`, `fx*(1-fy)`, `(1-fx)*fy`, `fx*fy`, clamp indices to grid bounds

**generate_forward_lut(camera_id, model, image_size, grid_step)** function:
- `model` is a `RefractiveProjectionModel` instance
- Build a regular grid of pixel coordinates: u in range(0, width, grid_step), v in range(0, height, grid_step)
- Call `model.cast_ray(grid_pixels)` to get origins and directions for all grid points
- Reshape into (grid_H, grid_W, 3) arrays
- Return ForwardLUT instance

**generate_forward_luts(calibration, lut_config)** function:
- Iterate over `calibration.ring_cameras` (skip auxiliary cameras)
- For each camera, construct a `RefractiveProjectionModel` from the camera's intrinsics/extrinsics and calibration's water_z/normal/n_air/n_water
- IMPORTANT: Use the post-undistortion K (`UndistortionMaps.K_new`) if undistortion maps are available. If not provided, use the raw K. Accept an optional `undistortion_maps: dict[str, UndistortionMaps] | None` parameter.
- Call `generate_forward_lut()` for each camera
- Log per-camera generation time: `"Generating LUT for camera {cam_id}... done ({elapsed:.1f}s)"`
- Return `dict[str, ForwardLUT]`

**Serialization:**

`save_forward_lut(lut, path)` — Save ForwardLUT to .npz file:
- Store: `grid_origins`, `grid_directions` as numpy arrays, `grid_step` as int, `image_size` as tuple, `camera_id` as string
- Include `config_hash` (string) in the saved data for cache invalidation

`load_forward_lut(path)` — Load ForwardLUT from .npz file:
- Return ForwardLUT instance, plus the stored `config_hash`

`compute_lut_hash(calibration_path, lut_config)` — Compute deterministic hash:
- Hash the contents of the calibration file + the LutConfig fields that affect LUT generation
- Use hashlib.sha256, return hex string (first 16 chars)

`save_forward_luts(luts, calibration_path, lut_config)` — Save all forward LUTs:
- Directory: `Path(calibration_path).parent / "luts"`
- File pattern: `{camera_id}_forward.npz`
- Include hash in each file

`load_forward_luts(calibration_path, lut_config)` — Load all forward LUTs:
- Check if files exist in `luts/` directory
- Check hash matches; if not, return None (caller regenerates)
- Return `dict[str, ForwardLUT]` or None

**Validation:**

`validate_forward_lut(lut, model, n_samples=100, seed=42)` function:
- Sample `n_samples` random pixel coordinates within the image bounds
- Call `lut.cast_ray(samples)` and `model.cast_ray(samples)`
- Compute max and mean angular error between LUT directions and model directions (in degrees)
- Compute max and mean origin distance (in metres)
- Return a dict with `max_angular_error_deg`, `mean_angular_error_deg`, `max_origin_error_m`, `mean_origin_error_m`
- Raise `ValueError` if max angular error exceeds 0.1 degrees (this indicates a bug, not just interpolation)

**3. Update `src/aquapose/calibration/__init__.py`:**

Add imports for the new public symbols:
- `ForwardLUT`
- `generate_forward_luts`
- `save_forward_luts`
- `load_forward_luts`
- `validate_forward_lut`
- `compute_lut_hash`

Add all to `__all__`.
  </action>
  <verify>
    <automated>cd C:/Users/tucke/PycharmProjects/AquaPose && python -c "
from aquapose.calibration.luts import ForwardLUT, generate_forward_lut, compute_lut_hash
from aquapose.engine.config import LutConfig, PipelineConfig
cfg = PipelineConfig()
assert hasattr(cfg, 'lut')
assert cfg.lut.tank_diameter == 2.0
assert cfg.lut.voxel_resolution_m == 0.02
print('Imports and config OK')
"</automated>
  </verify>
  <done>ForwardLUT class exists with cast_ray() bilinear interpolation. generate_forward_luts() builds LUTs from CalibrationData. Serialization round-trips through .npz files with hash-based cache invalidation. LutConfig is wired into PipelineConfig. validate_forward_lut() checks accuracy against RefractiveProjectionModel. All symbols exported from calibration package.</done>
</task>

<task type="auto">
  <name>Task 2: Write unit tests for ForwardLUT generation, interpolation accuracy, and serialization</name>
  <files>
    tests/unit/calibration/test_luts.py
  </files>
  <action>
Create `tests/unit/calibration/test_luts.py` with tests using synthetic camera data (no real calibration file needed). Use a simple pinhole camera with known parameters to construct a RefractiveProjectionModel, then test the ForwardLUT against it.

**Test fixtures:**

Create a `make_test_model()` helper that builds a RefractiveProjectionModel with known values:
- K: focal length ~500, principal point at (320, 240) for a 640x480 image
- R: identity (camera looking straight down)
- t: [0, 0, -0.5] (camera 0.5m above water surface at z=0)
- water_z: 0.0
- normal: [0, 0, -1]
- n_air: 1.0, n_water: 1.333

**Tests:**

1. `test_generate_forward_lut_grid_shape()`:
   - Generate a ForwardLUT with grid_step=10 on a 640x480 image
   - Assert grid_origins shape is (48, 64, 3) — ceil(480/10) x ceil(640/10)
   - Assert grid_directions shape matches
   - Assert all directions are unit vectors (norm ~1.0)

2. `test_forward_lut_cast_ray_matches_model()`:
   - Generate ForwardLUT with grid_step=1 (exact grid, no interpolation needed)
   - Sample 50 random pixel coordinates (within bounds, not on edges)
   - Compare LUT.cast_ray() vs model.cast_ray() for origins and directions
   - Assert max origin distance < 1e-4 m
   - Assert max angular error < 0.01 degrees

3. `test_forward_lut_interpolation_accuracy()`:
   - Generate ForwardLUT with grid_step=4 (requires interpolation for non-grid pixels)
   - Sample 100 random sub-pixel coordinates
   - Compare LUT.cast_ray() vs model.cast_ray()
   - Assert max origin distance < 1e-3 m
   - Assert max angular error < 0.1 degrees
   - This tests that bilinear interpolation preserves accuracy

4. `test_forward_lut_serialization_roundtrip(tmp_path)`:
   - Generate a ForwardLUT
   - Save to tmp_path via save_forward_lut()
   - Load back via load_forward_lut()
   - Assert grid_origins and grid_directions match exactly (np.allclose)
   - Assert camera_id, grid_step, image_size match

5. `test_compute_lut_hash_changes_with_config()`:
   - Create two LutConfig with different voxel_resolution_m
   - Assert compute_lut_hash() returns different hashes
   - Create two identical LutConfig
   - Assert compute_lut_hash() returns same hash

6. `test_validate_forward_lut_passes()`:
   - Generate a ForwardLUT with grid_step=1
   - Call validate_forward_lut() — should return without error
   - Check that max_angular_error_deg < 0.01

7. `test_forward_lut_edge_pixels()`:
   - Query LUT with pixels at image corners (0,0), (W-1,0), (0,H-1), (W-1,H-1)
   - Should return valid ray origins and directions (no NaN, no crash)

All tests use `torch.manual_seed(42)` and `np.random.seed(42)` for reproducibility. Tests should NOT require real calibration files or CUDA — run entirely on CPU with synthetic camera parameters.

NOTE: For `test_compute_lut_hash_changes_with_config`, the function needs a calibration file path. Use a tmp_path fixture: write a small dummy JSON file (just `{"version": "test"}`) to tmp_path, then pass that path to compute_lut_hash(). The hash is over file contents + config, so the file just needs to exist and be readable.
  </action>
  <verify>
    <automated>cd C:/Users/tucke/PycharmProjects/AquaPose && hatch run python -m pytest tests/unit/calibration/test_luts.py -x -v 2>&1 | tail -30</automated>
  </verify>
  <done>All 7 tests pass. ForwardLUT interpolation matches RefractiveProjectionModel.cast_ray() within tolerance. Serialization round-trips correctly. Hash changes with config. Edge pixels handled without errors.</done>
</task>

</tasks>

<verification>
1. `python -c "from aquapose.calibration import ForwardLUT, generate_forward_luts, validate_forward_lut"` succeeds
2. `python -c "from aquapose.engine.config import LutConfig, PipelineConfig; cfg = PipelineConfig(); assert hasattr(cfg, 'lut')"` succeeds
3. `hatch run python -m pytest tests/unit/calibration/test_luts.py -x -v` — all tests pass
4. `hatch run check` — lint and typecheck pass
</verification>

<success_criteria>
- ForwardLUT class precomputes per-camera pixel-to-ray grids and serves bilinear-interpolated queries
- ForwardLUT.cast_ray() matches RefractiveProjectionModel.cast_ray() within 0.1 degree angular error
- Forward LUTs serialize to .npz files and reload with hash-based cache invalidation
- LutConfig is wired into PipelineConfig with tank geometry defaults
- Unit tests validate interpolation accuracy, serialization, and edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/23-refractive-lookup-tables/23-01-SUMMARY.md`
</output>
