---
phase: 25-association-scoring-and-clustering
plan: 02
type: tdd
wave: 2
depends_on: [25-01]
files_modified:
  - src/aquapose/core/association/clustering.py
  - src/aquapose/core/association/stage.py
  - src/aquapose/core/association/types.py
  - src/aquapose/core/association/__init__.py
  - src/aquapose/engine/pipeline.py
  - tests/unit/core/association/test_clustering.py
autonomous: true
requirements: [ASSOC-02]

must_haves:
  truths:
    - "Tracklets are clustered into global fish identity groups via connected components followed by Leiden algorithm"
    - "Same-camera tracklets with detection-backed temporal overlap are prevented from sharing a cluster via must-not-link constraints"
    - "Same-camera non-overlapping fragments within a cluster are merged with interpolated centroids filling gaps"
    - "Resulting tracklet_groups contains at most expected_fish_count clusters, each listing constituent tracklets"
    - "AssociationStage replaces AssociationStubStage in the pipeline and populates PipelineContext.tracklet_groups"
    - "Singleton unassociated tracklets are kept as single-tracklet TrackletGroups with low confidence"
    - "HandoffState dataclass defined with correct fields but populated as empty stub"
  artifacts:
    - path: "src/aquapose/core/association/clustering.py"
      provides: "Leiden clustering with must-not-link constraints and fragment merging"
      exports: ["build_must_not_link", "cluster_tracklets", "merge_fragments"]
    - path: "src/aquapose/core/association/stage.py"
      provides: "AssociationStage satisfying Stage Protocol"
      exports: ["AssociationStage"]
    - path: "src/aquapose/core/association/types.py"
      provides: "HandoffState dataclass"
      contains: "class HandoffState"
    - path: "tests/unit/core/association/test_clustering.py"
      provides: "Unit tests for clustering and fragment merging"
      min_lines: 100
  key_links:
    - from: "src/aquapose/core/association/clustering.py"
      to: "src/aquapose/core/association/scoring.py"
      via: "score_all_pairs() provides the weighted edges for graph construction"
      pattern: "score_all_pairs"
    - from: "src/aquapose/core/association/stage.py"
      to: "src/aquapose/core/association/clustering.py"
      via: "AssociationStage.run() calls cluster_tracklets()"
      pattern: "cluster_tracklets"
    - from: "src/aquapose/engine/pipeline.py"
      to: "src/aquapose/core/association/stage.py"
      via: "build_stages() instantiates AssociationStage replacing AssociationStubStage"
      pattern: "AssociationStage"
---

<objective>
Implement Leiden-based tracklet clustering with must-not-link constraints, fragment merging, and the AssociationStage that wires everything into the pipeline. This is SPECSEED Steps 2-4 (graph construction, clustering, fragment merging).

Purpose: Produces the `tracklet_groups` that downstream stages (Midline, Reconstruction) use to know which tracklets belong to the same fish. Without clustering, the pipeline has no cross-camera identity.

Output: `clustering.py` module with `build_must_not_link()`, `cluster_tracklets()`, `merge_fragments()` functions; `AssociationStage` in `stage.py`; `HandoffState` in `types.py`; pipeline rewire replacing AssociationStubStage; unit tests.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-association-scoring-and-clustering/25-01-SUMMARY.md
@.planning/phases/22-pipeline-scaffolding/22-01-SUMMARY.md
@.planning/phases/22-pipeline-scaffolding/22-02-SUMMARY.md

<interfaces>
<!-- Key types and contracts from Plan 25-01 that this plan depends on. -->

From src/aquapose/core/association/scoring.py (created in 25-01):
```python
class AssociationConfigLike(Protocol):
    ray_distance_threshold: float
    score_min: float
    t_min: int
    t_saturate: int
    early_k: int
    ghost_pixel_threshold: float
    min_shared_voxels: int

def score_all_pairs(
    tracks_2d: dict[str, list[Tracklet2D]],
    forward_luts: dict[str, ForwardLUT],
    inverse_lut: InverseLUT,
    detections: list[dict[str, list[tuple[float, float]]]],
    config: AssociationConfigLike,
) -> dict[tuple[tuple[str, int], tuple[str, int]], float]:
    # Returns {((cam_a, track_a), (cam_b, track_b)): score}
```

From src/aquapose/engine/config.py (expanded in 25-01):
```python
@dataclass(frozen=True)
class AssociationConfig:
    ray_distance_threshold: float = 0.03
    score_min: float = 0.3
    t_min: int = 10
    t_saturate: int = 100
    early_k: int = 10
    expected_fish_count: int = 9
    ghost_pixel_threshold: float = 50.0
    min_shared_voxels: int = 100
    leiden_resolution: float = 1.0
    max_merge_gap: int = 30
```

From src/aquapose/core/tracking/types.py:
```python
@dataclass(frozen=True)
class Tracklet2D:
    camera_id: str
    track_id: int
    frames: tuple        # tuple[int, ...]
    centroids: tuple     # tuple[tuple[float, float], ...]
    bboxes: tuple        # tuple[tuple[float, float, float, float], ...]
    frame_status: tuple  # tuple[str, ...] — "detected" or "coasted"
```

From src/aquapose/core/association/types.py:
```python
@dataclass(frozen=True)
class TrackletGroup:
    fish_id: int
    tracklets: tuple     # tuple[Tracklet2D, ...] (generic tuple at runtime)
    confidence: float | None = None
```

From src/aquapose/engine/pipeline.py (current stub to replace):
```python
class AssociationStubStage:
    """Stub that passes through empty tracklet groups."""
    def run(self, context: PipelineContext) -> PipelineContext:
        context.tracklet_groups = []
        return context
```

From src/aquapose/core/context.py:
```python
@dataclass
class PipelineContext:
    tracks_2d: dict | None = None        # dict[str, list[Tracklet2D]]
    tracklet_groups: list | None = None   # list[TrackletGroup]
    detections: list | None = None        # list[dict[str, list[Detection]]]
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement clustering, fragment merging, HandoffState, and AssociationStage</name>
  <files>
    src/aquapose/core/association/clustering.py
    src/aquapose/core/association/stage.py
    src/aquapose/core/association/types.py
    src/aquapose/core/association/__init__.py
    src/aquapose/engine/pipeline.py
  </files>
  <action>
**Step 1: Add HandoffState to types.py**

Add a `HandoffState` frozen dataclass to `src/aquapose/core/association/types.py`. This is a typed stub for future chunk orchestration — defined with correct fields but populated with None/empty values by Stage 3. Per CONTEXT.md: "Contracts exist for future chunk orchestration; data deferred."

```python
@dataclass(frozen=True)
class HandoffState:
    """Chunk handoff state emitted by the Association stage.

    Typed stub for future chunk-boundary orchestration. Fields are defined
    but populated with None/empty values in v2.1 (single-chunk mode).

    Attributes:
        active_fish_ids: Global fish IDs active at chunk end. None in v2.1.
        per_id_3d_state: Per-fish 3D position/velocity at chunk end. None in v2.1.
        per_id_2d_state: Per-fish per-camera 2D state at chunk end. None in v2.1.
        per_id_confidence: Per-fish association confidence at boundary. None in v2.1.
    """
    active_fish_ids: tuple | None = None
    per_id_3d_state: dict | None = None
    per_id_2d_state: dict | None = None
    per_id_confidence: dict | None = None
```

Update `__all__` in types.py to include HandoffState.

**Step 2: Create src/aquapose/core/association/clustering.py**

This module implements SPECSEED Steps 2-4.

Use a `ClusteringConfigLike` Protocol for config fields consumed by this module: `score_min`, `expected_fish_count`, `leiden_resolution`, `max_merge_gap`. Same IB-003 pattern as scoring.py.

Functions to implement:

1. **`build_must_not_link(tracks_2d)`** — Build the must-not-link constraint set (SPECSEED Step 3.1):
   - Input: `dict[str, list[Tracklet2D]]` — per-camera tracklets.
   - For each camera, check all pairs of tracklets. Two tracklets are must-not-link if they overlap in **detection-backed frames** — frames where both have `frame_status == "detected"`.
   - Return: `set[frozenset[tuple[str, int]]]` — set of frozen pairs of tracklet keys `(camera_id, track_id)`.
   - Coasted overlap is NOT a must-not-link trigger — those pairs are fragment merge candidates.

2. **`cluster_tracklets(scores, tracks_2d, must_not_link, config)`** — Cluster tracklets into fish groups (SPECSEED Steps 2-3):
   - `scores`: dict from `score_all_pairs()` — `{(key_a, key_b): score}`.
   - `tracks_2d`: all tracklets by camera.
   - `must_not_link`: from `build_must_not_link()`.
   - `config`: ClusteringConfigLike.
   - Algorithm:
     a. **Build weighted undirected graph** using `igraph.Graph()`. Nodes = all tracklet keys (camera_id, track_id). Edges = scored pairs with weight = score.
     b. **Connected components**: Split into components. Each component clustered independently.
     c. **Leiden clustering**: For each component, run `leidenalg.find_partition()` with `RBConfigurationVertexPartition` using `config.leiden_resolution` as resolution parameter. Import leidenalg with deferred import inside the function.
     d. **Must-not-link enforcement**: After Leiden produces clusters, check each cluster. If a cluster contains a must-not-link pair:
        - Remove the weakest internal edge between the conflicting tracklets.
        - Re-run Leiden on the affected subgraph.
        - If violations persist after one re-split attempt, force-separate: evict the tracklet with lower total affinity to the cluster (sum of edge weights to other cluster members) into a singleton.
     e. **Singleton handling**: Tracklets not connected to any edge become single-tracklet clusters with confidence = 0.0 (per CONTEXT.md: kept as low-confidence groups).
     f. **Diagnostic warning**: If cluster count != config.expected_fish_count, emit `logger.warning(...)` with the count and expected count.
   - Return: `list[TrackletGroup]` — each group has `fish_id` (0-indexed), `tracklets` tuple, and `confidence` (mean internal edge weight, or 0.0 for singletons).

3. **`merge_fragments(groups, config)`** — Merge same-camera fragments within each cluster (SPECSEED Step 4):
   - For each TrackletGroup, identify tracklets from the same camera.
   - **Non-overlapping in time** and separated by <= `config.max_merge_gap` frames: merge into a single Tracklet2D.
     - Discard all coasted frames from the earlier-ending tracklet.
     - Keep detected frames from both tracklets.
     - If a gap exists between the last detected frame of fragment A and first detected frame of fragment B, linearly interpolate centroids. Tag interpolated frames as `"interpolated"` (new frame_status value per CONTEXT.md).
     - Merged bboxes: use last known bbox for interpolated frames (or linearly interpolate x,y,w,h).
   - **Overlap only in coasted frames**: Trim coasted overlap from the dying tracklet, then merge as above.
   - **Detection-backed overlap**: Should not occur (prevented by must-not-link). If detected, log a warning and skip the merge.
   - Fragments separated by more than `config.max_merge_gap` frames: keep separate within the group (do not merge).
   - Return: `list[TrackletGroup]` — same groups with merged tracklets.

**Step 3: Create src/aquapose/core/association/stage.py**

Create `AssociationStage` that satisfies the Stage Protocol:

```python
class AssociationStage:
    """Cross-camera tracklet association (Stage 3).

    Scores all cross-camera tracklet pairs using ray-ray geometry and
    clusters them into global fish identity groups via Leiden algorithm.
    """

    def __init__(self, config: Any) -> None:
        # Store config (Any-typed to avoid circular engine->core import,
        # same pattern as TrackingStage)
        self._config = config

    def run(self, context: PipelineContext) -> PipelineContext:
        # Deferred imports for scoring and clustering (same pattern as TrackingStage)
        from aquapose.core.association.scoring import score_all_pairs
        from aquapose.core.association.clustering import (
            build_must_not_link,
            cluster_tracklets,
            merge_fragments,
        )

        tracks_2d = context.get("tracks_2d")
        detections = context.get("detections")

        # Extract detection centroids for ghost penalty
        # detections is list[dict[str, list[Detection]]] — need to extract centroids
        det_centroids = _extract_centroids(detections)

        # Need forward_luts and inverse_lut — these should be loaded/cached
        # Use deferred import to load LUTs via config paths
        # For now, if no LUTs available, produce empty groups (graceful degradation)
        forward_luts, inverse_lut = _load_luts(self._config)
        if forward_luts is None or inverse_lut is None:
            logger.warning("LUTs not available — association producing empty groups")
            context.tracklet_groups = []
            return context

        # Step 1: Score all pairs
        scores = score_all_pairs(tracks_2d, forward_luts, inverse_lut, det_centroids, self._config.association)

        # Step 2-3: Build constraints and cluster
        must_not_link = build_must_not_link(tracks_2d)
        groups = cluster_tracklets(scores, tracks_2d, must_not_link, self._config.association)

        # Step 4: Merge fragments
        groups = merge_fragments(groups, self._config.association)

        context.tracklet_groups = groups
        return context
```

The `_extract_centroids()` helper converts Detection objects to simple (u,v) tuples for the scoring function. The `_load_luts()` helper loads pre-generated LUTs from the configured paths (or generates on-the-fly if not cached). Use deferred imports for calibration LUT functions.

**Important**: The stage accepts `config` as `Any` (not `PipelineConfig`) to avoid the circular engine->core import. Access `config.association` for AssociationConfig fields, `config.lut` for LutConfig, `config.calibration_path` for calibration data.

**Step 4: Wire AssociationStage into pipeline**

In `src/aquapose/engine/pipeline.py`:
- Remove `AssociationStubStage` class entirely.
- In `build_stages()`, replace `AssociationStubStage()` with `AssociationStage(config)`.
- Import AssociationStage from `aquapose.core.association`.
- Update the `__all__` or relevant imports.

**Step 5: Update core/association/__init__.py**

Add exports for HandoffState, AssociationStage, and the clustering functions. Update `__all__`.
  </action>
  <verify>
    <automated>cd C:/Users/tucke/PycharmProjects/AquaPose && python -c "from aquapose.core.association import AssociationStage, HandoffState; from aquapose.core.association.clustering import build_must_not_link, cluster_tracklets, merge_fragments; print('imports OK')" && hatch run lint</automated>
  </verify>
  <done>
    - HandoffState frozen dataclass defined in types.py with typed stub fields
    - build_must_not_link correctly identifies same-camera detection-backed overlaps
    - cluster_tracklets uses igraph + leidenalg with must-not-link enforcement and singleton handling
    - merge_fragments handles non-overlapping, coasted-overlap, and gap interpolation with "interpolated" frame_status
    - AssociationStage replaces AssociationStubStage in build_stages()
    - Diagnostic warning emitted when cluster count != expected_fish_count
    - All symbols exported from core/association/__init__.py
  </done>
</task>

<task type="auto">
  <name>Task 2: Write unit tests for clustering and stage</name>
  <files>
    tests/unit/core/association/test_clustering.py
  </files>
  <action>
Create `tests/unit/core/association/test_clustering.py` with these test cases:

**Test fixtures:**
- Helper to build synthetic Tracklet2D with controlled frames, centroids, frame_status.
- `MockClusteringConfig` frozen dataclass satisfying ClusteringConfigLike.
- Helper to build simple score dicts for known graph structures.

**Tests:**

1. **`test_build_must_not_link_detected_overlap`** — Two tracklets from the same camera with overlapping detected frames. Should produce a must-not-link pair.

2. **`test_build_must_not_link_coasted_overlap_allowed`** — Two same-camera tracklets where overlap frames are all coasted on one tracklet. Should NOT produce a must-not-link pair (these are fragment candidates).

3. **`test_build_must_not_link_different_cameras`** — Two tracklets from different cameras. Should never produce a must-not-link pair regardless of overlap.

4. **`test_cluster_tracklets_two_fish`** — 4 tracklets from 2 cameras (2 per camera), with high scores between cross-camera same-fish pairs and zero scores between different-fish pairs. Should produce exactly 2 clusters, each containing 2 tracklets (one from each camera).

5. **`test_cluster_tracklets_must_not_link_splits`** — 3 tracklets where Leiden would naturally group them together, but two of them are must-not-link. The conflicting tracklet should be evicted to a singleton.

6. **`test_cluster_tracklets_singletons`** — A tracklet with no scored edges. Should appear as a singleton TrackletGroup with confidence 0.0.

7. **`test_cluster_tracklets_warns_on_wrong_count`** — Set expected_fish_count=2 but produce 3 clusters. Check that a warning is logged (use `caplog` or mock logger).

8. **`test_merge_fragments_non_overlapping`** — Two same-camera tracklets in a cluster with non-overlapping frames separated by a small gap. Should be merged with interpolated centroids filling the gap. Verify interpolated frames have `frame_status == "interpolated"`.

9. **`test_merge_fragments_coasted_overlap`** — Two same-camera tracklets where the earlier one has coasted tail overlapping the later one's detected start. Coasted frames should be discarded, detected frames kept, gap interpolated.

10. **`test_merge_fragments_exceeds_max_gap`** — Two same-camera tracklets separated by more than max_merge_gap frames. Should NOT be merged — both kept as separate tracklets in the group.

11. **`test_merge_fragments_preserves_cross_camera`** — Tracklets from different cameras within the same group should NOT be merged (merging is same-camera only).

12. **`test_association_stage_produces_groups`** — Integration-level test: create an AssociationStage with mock config, feed a PipelineContext with tracks_2d and detections. Verify that context.tracklet_groups is populated (not None). This test can use mocked LUTs that return controlled results, or test the graceful degradation path (no LUTs -> empty groups).

For leidenalg tests: mark tests that require `leidenalg` with `pytest.importorskip("leidenalg")` at the top of the test or use a pytest marker, so CI environments without leidenalg don't fail. Alternatively, the import should be guarded inside cluster_tracklets itself.
  </action>
  <verify>
    <automated>cd C:/Users/tucke/PycharmProjects/AquaPose && hatch run test tests/unit/core/association/test_clustering.py -v && hatch run test</automated>
  </verify>
  <done>
    - All 12 tests pass
    - Must-not-link correctly distinguishes detected vs coasted overlap
    - Leiden clustering produces correct groups for known graph structures
    - Must-not-link enforcement evicts conflicting tracklets
    - Singletons handled as low-confidence groups
    - Fragment merging handles non-overlapping, coasted overlap, and gap interpolation
    - max_merge_gap respected
    - Cross-camera tracklets not merged
    - AssociationStage integration test confirms pipeline wiring
    - Full test suite passes (no regressions)
  </done>
</task>

</tasks>

<verification>
```bash
cd C:/Users/tucke/PycharmProjects/AquaPose
hatch run test tests/unit/core/association/ -v
hatch run lint
hatch run test  # full suite, no regressions
```
</verification>

<success_criteria>
- Leiden clustering groups tracklets into fish identity clusters using affinity scores
- Must-not-link constraints prevent same-camera detection-overlapping tracklets from sharing a cluster
- Fragment merging stitches same-camera non-overlapping tracklets with interpolated gap frames tagged "interpolated"
- AssociationStage replaces AssociationStubStage in the 5-stage pipeline
- PipelineContext.tracklet_groups populated with TrackletGroup list
- HandoffState defined as typed stub for future chunk orchestration
- Diagnostic warning when cluster count != expected_fish_count
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/25-association-scoring-and-clustering/25-02-SUMMARY.md`
</output>
